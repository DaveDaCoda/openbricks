From 00bbcb9c1196782993e19fb20d6135da34ba6bd2 Mon Sep 17 00:00:00 2001
From: warped-rudi <r.ihle@s-t.de>
Date: Wed, 5 Aug 2015 20:16:44 +0200
Subject: [PATCH 2/3] video: mxc_hdmi: Add new option 'auto' for RGB Quant
 Range setting

This new option, which is now the default, will automatically use
full range, when the sink announces that it supports quantisation
overriding. Otherwise, the default range (i.e. limited) is used.
---
 drivers/video/mxc/mxc_hdmi.c |   41 ++++++++++++++++++++++++++++++++---------
 1 file changed, 32 insertions(+), 9 deletions(-)

diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index 43ccd29..75b0a1b 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -208,10 +208,11 @@ extern void mxc_hdmi_cec_handle(u16 cec_stat);
 static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event);
 static void hdmi_enable_overflow_interrupts(void);
 static void hdmi_disable_overflow_interrupts(void);
+static unsigned int getRGBQuantRange(struct mxc_hdmi *hdmi);
 
-static char *rgb_quant_range = "default";
+static char *rgb_quant_range = "auto";
 module_param(rgb_quant_range, charp, S_IRUGO);
-MODULE_PARM_DESC(rgb_quant_range, "RGB Quant Range (default, limited, full)");
+MODULE_PARM_DESC(rgb_quant_range, "RGB Quant Range (auto, default, limited, full)");
 
 static struct platform_device_id imx_hdmi_devtype[] = {
 	{
@@ -336,8 +337,9 @@ static ssize_t mxc_hdmi_show_rgb_quant_range(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+	int n;
 
-	switch (hdmi->hdmi_data.rgb_quant_range) {
+	switch (getRGBQuantRange(hdmi)) {
 	case HDMI_FC_AVICONF2_RGB_QUANT_LIMITED_RANGE: 
 		strcpy(buf, "limited\n");
 		break;
@@ -350,7 +352,14 @@ static ssize_t mxc_hdmi_show_rgb_quant_range(struct device *dev,
 		break;
 	};
 
-	return strlen(buf);
+	n = strlen(buf);
+
+	if (hdmi->hdmi_data.rgb_quant_range == HDMI_FC_AVICONF2_RGB_QUANT_MASK) {
+		strcpy(buf + n - 1, " (auto)\n");
+		n += 7;
+	}
+
+	return n;
 }
 
 static ssize_t mxc_hdmi_store_rgb_quant_range(struct device *dev,
@@ -365,6 +374,8 @@ static ssize_t mxc_hdmi_store_rgb_quant_range(struct device *dev,
 		hdmi->hdmi_data.rgb_quant_range = HDMI_FC_AVICONF2_RGB_QUANT_FULL_RANGE;
 	} else if (sysfs_streq("default", buf)) {
 		hdmi->hdmi_data.rgb_quant_range = HDMI_FC_AVICONF2_RGB_QUANT_DEFAULT;
+	} else if (sysfs_streq("auto", buf)) {
+		hdmi->hdmi_data.rgb_quant_range = HDMI_FC_AVICONF2_RGB_QUANT_MASK;
 	} else {
 		ret = -EINVAL;
 		goto out;
@@ -491,12 +502,23 @@ static void hdmi_video_sample(struct mxc_hdmi *hdmi)
 	hdmi_writeb(0x0, HDMI_TX_BCBDATA1);
 }
 
+static unsigned int getRGBQuantRange(struct mxc_hdmi *hdmi)
+{
+	if (hdmi->hdmi_data.rgb_quant_range != HDMI_FC_AVICONF2_RGB_QUANT_MASK)
+	      return hdmi->hdmi_data.rgb_quant_range;
+
+	return hdmi->edid_cfg.cea_rgb_range_selectable ? 
+		HDMI_FC_AVICONF2_RGB_QUANT_FULL_RANGE : HDMI_FC_AVICONF2_RGB_QUANT_DEFAULT;
+}
+
 static int isColorSpaceConversion(struct mxc_hdmi *hdmi)
 {
+	unsigned int rgb_quant_range = getRGBQuantRange(hdmi);
+
 	return (hdmi->hdmi_data.enc_in_format != hdmi->hdmi_data.enc_out_format) ||
 		(hdmi->hdmi_data.enc_out_format == RGB &&
-		  ((hdmi->hdmi_data.rgb_quant_range == HDMI_FC_AVICONF2_RGB_QUANT_LIMITED_RANGE) ||
-		   (hdmi->hdmi_data.rgb_quant_range == HDMI_FC_AVICONF2_RGB_QUANT_DEFAULT && hdmi->vic > 1)));
+		  ((rgb_quant_range == HDMI_FC_AVICONF2_RGB_QUANT_LIMITED_RANGE) ||
+		   (rgb_quant_range == HDMI_FC_AVICONF2_RGB_QUANT_DEFAULT && hdmi->vic > 1)));
 }
 
 static int isColorSpaceDecimation(struct mxc_hdmi *hdmi)
@@ -1455,8 +1477,7 @@ static void hdmi_config_AVI(struct mxc_hdmi *hdmi)
 	 ********************************************/
 
 	val = HDMI_FC_AVICONF2_IT_CONTENT_NO_DATA | ext_colorimetry |
-		hdmi->hdmi_data.rgb_quant_range |
-		HDMI_FC_AVICONF2_SCALING_NONE;
+		getRGBQuantRange(hdmi) | HDMI_FC_AVICONF2_SCALING_NONE;
 	hdmi_writeb(val, HDMI_FC_AVICONF2);
 
 	/********************************************
@@ -2716,8 +2737,10 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 		hdmi->hdmi_data.rgb_quant_range = HDMI_FC_AVICONF2_RGB_QUANT_LIMITED_RANGE;
 	} else if (!strcasecmp(rgb_quant_range, "full")) {
 		hdmi->hdmi_data.rgb_quant_range = HDMI_FC_AVICONF2_RGB_QUANT_FULL_RANGE;
-	} else {
+	} else if (!strcasecmp(rgb_quant_range, "default")) {
 		hdmi->hdmi_data.rgb_quant_range = HDMI_FC_AVICONF2_RGB_QUANT_DEFAULT;
+	} else {
+		hdmi->hdmi_data.rgb_quant_range = HDMI_FC_AVICONF2_RGB_QUANT_MASK;
 	}
 
 	ret = devm_request_irq(&hdmi->pdev->dev, irq, mxc_hdmi_hotplug, IRQF_SHARED,
-- 
1.7.9.5

