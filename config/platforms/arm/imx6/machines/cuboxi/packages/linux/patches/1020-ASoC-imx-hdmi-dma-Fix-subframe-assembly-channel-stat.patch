From e82418fcc79dc6026494acc5c06356544ded8f6f Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Sat, 9 Aug 2014 20:17:34 +0200
Subject: [PATCH 1020/1020] ASoC: imx-hdmi-dma: Fix subframe assembly /
 channel status in HBR mode.

High bitrate mode is siganlled to the driver as passthrough with 8 channels.
However, it is infact a two channel mode. This patch corrects the handling
of priv->frame_idx to create proper channel status information.
---
 sound/soc/fsl/imx-hdmi-dma.c |   48 +++++++++++++++++++++++++++++-------------
 1 file changed, 33 insertions(+), 15 deletions(-)

diff --git a/sound/soc/fsl/imx-hdmi-dma.c b/sound/soc/fsl/imx-hdmi-dma.c
index 0ca505b..b37fce5 100644
--- a/sound/soc/fsl/imx-hdmi-dma.c
+++ b/sound/soc/fsl/imx-hdmi-dma.c
@@ -253,7 +253,7 @@ static u32 hdmi_dma_add_frame_info(struct hdmi_dma_priv *priv,
 	/* fill c (channel status) */
 	if (priv->frame_idx < 42) {
 		iec_header.B.channel =
-			(iec_header.B.linear_pcm == 0) ? subframe_idx : 0;
+			(iec_header.B.linear_pcm == 0) ? (subframe_idx + 1) : 0;
 		subframe.B.c = iec_header.U >> priv->frame_idx;
 	}
 
@@ -262,9 +262,8 @@ static u32 hdmi_dma_add_frame_info(struct hdmi_dma_priv *priv,
 
 	/* fill data */
 	if (priv->sample_bits == 16)
-		subframe.B.data = pcm_data << 8;
-	else
-		subframe.B.data = pcm_data;
+		pcm_data <<= 8;
+	subframe.B.data = pcm_data;
 
 	/* fill p (parity) Note: Do not include b ! */
 	subframe.B.p = odd_ones(subframe.U);
@@ -279,7 +278,7 @@ static u32 hdmi_dma_add_frame_info(struct hdmi_dma_priv *priv,
 static void init_table(int channels)
 {
 	unsigned char *p = g_packet_head_table;
-	int i, map_sel, ch = 0;
+	int i, map_sel, ch;
 
 	for (i = 0; i < 48; i++) {
 		int b = 0;
@@ -684,15 +683,22 @@ static int hdmi_dma_copy(struct snd_pcm_substream *substream, int channel,
 	struct hdmi_dma_priv *priv = runtime->private_data;
 	unsigned int count = frames_to_bytes(runtime, frames);
 	unsigned int pos_bytes = frames_to_bytes(runtime, pos);
-	int channel_no, pcm_idx, subframe_no, bits_left, sample_bits, map_sel;
-	u32 pcm_data[8], pcm_temp, *hw_buf, sample_block;
+	int channel_no, pcm_idx, subframe_idx, bits_left, sample_bits, map_sel;
+	u32 pcm_data[8], pcm_temp, *hw_buf, sample_block, inc_mask;
 
 	/* Adding frame info to pcm data from userspace and copy to hw_buffer */
 	hw_buf = (u32 *)(priv->hw_buffer.area + (pos_bytes * priv->buffer_ratio));
 
 	sample_bits = priv->sample_align * 8;
 	sample_block = priv->sample_align * priv->channels;
-	map_sel = (iec_header.B.linear_pcm == 0) ? (priv->channels / 2) : 0;
+
+	if (iec_header.B.linear_pcm == 0) {
+		map_sel = priv->channels / 2;
+		inc_mask = 1 << (priv->channels - 1);
+	} else {
+		map_sel = 0;
+		inc_mask = 0xaa;
+	}
 
 	while (count > 0) {
 		if (copy_from_user(pcm_data, buf, sample_block))
@@ -707,11 +713,17 @@ static int hdmi_dma_copy(struct snd_pcm_substream *substream, int channel,
 			bits_left = 32;
 			for (;;) {
 				/* re-map channels */
-				subframe_no = channel_maps_alsa_cea[map_sel][channel_no];
+				subframe_idx = channel_maps_alsa_cea[map_sel][channel_no];
 
 				/* Save the header info to the audio dma buffer */
-				hw_buf[subframe_no] = hdmi_dma_add_frame_info(
-							priv, pcm_temp, subframe_no + 1);
+				hw_buf[subframe_idx] = hdmi_dma_add_frame_info(
+								priv, pcm_temp, subframe_idx);
+
+				if (inc_mask & (1 << channel_no)) {
+					if (++priv->frame_idx == 192)
+						priv->frame_idx = 0;
+				}
+
 				channel_no++;
 
 				if (bits_left <= sample_bits)
@@ -723,10 +735,6 @@ static int hdmi_dma_copy(struct snd_pcm_substream *substream, int channel,
 		} while (channel_no < priv->channels);
 
 		hw_buf += priv->channels;
-
-		priv->frame_idx++;
-		if (priv->frame_idx == 192)
-			priv->frame_idx = 0;
 	}
 
 	return 0;
@@ -886,6 +894,16 @@ static void hdmi_dma_trigger_init(struct snd_pcm_substream *substream,
 	hbr = (iec_header.B.linear_pcm != 0 && priv->channels == 8);
 	hdmi_audio_writeb(AHB_DMA_CONF0, HBR, !!hbr);
 
+	/*
+	 * Override AES3 - parameter: This is a temporary hack for
+	 * callers that provide incorrect information when opening
+	 * the device. 0x09 (i.e. 768K) is the only acceptable value.
+	 */
+	if (hbr) {
+		iec_header.B.sample_freq = 0x09;
+		iec_header.B.org_sample_freq = 0x00;
+	}
+
 	priv->frame_idx = 0;
 
 	/* Copy data by buffer_bytes */
-- 
1.7.9.5

