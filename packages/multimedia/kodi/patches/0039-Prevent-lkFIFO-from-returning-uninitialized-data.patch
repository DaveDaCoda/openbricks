From 5dee77ae7dc1233ba2ff87ee25277a7643640a61 Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Sun, 2 Oct 2016 18:43:52 +0200
Subject: [PATCH] Prevent lkFIFO from returning uninitialized data

---
 .../VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp    | 17 +++++++++++++----
 xbmc/linux/imx/IMX.h                                    | 16 ++++++++--------
 2 files changed, 21 insertions(+), 12 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
index a3d993b..717b5ce 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
@@ -872,7 +872,7 @@ void CIMXCodec::Process()
   {
     RecycleFrameBuffers();
     SAFE_DELETE(task);
-    if (!(task = m_decInput.pop()))
+    if (!m_decInput.pop(task))
       task = new VPUTask();
 
 #if defined(IMX_PROFILE) || defined(IMX_PROFILE_BUFFERS)
@@ -1035,7 +1035,11 @@ void CIMXCodec::Process()
 
       if (m_decRet & VPU_DEC_NO_ENOUGH_BUF && m_decOutput.size())
       {
-        m_decOutput.pop()->Release();
+        CDVDVideoCodecIMXBuffer *buffer;
+
+        if (m_decOutput.pop(buffer))
+          buffer->Release();
+
         FlushVPU();
         continue;
       }
@@ -1111,8 +1115,13 @@ void CIMXCodec::ExitError(const char *msg, ...)
 
 bool CIMXCodec::GetPicture(DVDVideoPicture* pDvdVideoPicture)
 {
-  CDVDVideoCodecIMXBuffer *pIMXBuffer = m_decOutput.pop();
-  assert(pIMXBuffer);
+  CDVDVideoCodecIMXBuffer *pIMXBuffer;
+
+  if( !m_decOutput.pop(pIMXBuffer))
+  {
+    memset(pDvdVideoPicture, 0, sizeof(*pDvdVideoPicture));
+    return false;
+  }
 
 #ifdef IMX_PROFILE
   static unsigned int previous = 0;
diff --git a/xbmc/linux/imx/IMX.h b/xbmc/linux/imx/IMX.h
index c548633..24a380c 100644
--- a/xbmc/linux/imx/IMX.h
+++ b/xbmc/linux/imx/IMX.h
@@ -80,23 +80,22 @@ public:
   lkFIFO() { m_size = queue.max_size(); queue.clear(); m_abort = false; }
 
 public:
-  T pop()
+  bool pop(T &item)
   {
     std::unique_lock<std::mutex> m_lock(lkqueue);
     m_abort = false;
     while (!queue.size() && !m_abort)
       read.wait(m_lock);
 
-    T val;
-    if (!queue.empty())
-    {
-      val = queue.front();
-      queue.pop_front();
-    }
+    if (queue.empty())
+      return false;
+
+    item = queue.front();
+    queue.pop_front();
 
     m_lock.unlock();
     write.notify_one();
-    return val;
+    return true;
   }
 
   bool push(const T& item)
@@ -110,6 +109,7 @@ public:
       return false;
 
     queue.push_back(item);
+
     m_lock.unlock();
     read.notify_one();
     return true;
-- 
1.9.1

