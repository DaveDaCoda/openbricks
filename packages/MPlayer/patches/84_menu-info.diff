diff -Naur MPlayer-1.0pre6.orig/libmenu/menu_param.c MPlayer-1.0pre6/libmenu/menu_param.c
--- MPlayer-1.0pre6.orig/libmenu/menu_param.c	2004-12-30 19:38:06.757872344 +0100
+++ MPlayer-1.0pre6/libmenu/menu_param.c	2004-12-30 19:54:32.702985904 +0100
@@ -7,6 +7,12 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <ctype.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <mntent.h>
+#include <sys/vfs.h>
 
 
 #include "../config.h"
@@ -52,6 +58,43 @@
 
 extern m_config_t* mconfig;
 
+static int is_part(char *name) {
+  if(*name != 'h' && *name != 's')
+    return 0;
+  name++;
+  if(*name != 'd')
+    return 0;
+  name++;
+  if(*name < 'a' || *name > 'z')
+    return 0;
+  name++;
+  if(*name < '0' || *name > '9')
+    return 0;
+  return 1;
+}
+
+static char *part_size(char *part) {
+  static char size[32];
+  char name[] = "/dev/xdxx";
+  struct mntent *mpoint;
+  struct statfs buf;
+  FILE *mtab;
+
+  strcpy(name+5, part);
+  mtab = setmntent("/proc/mounts", "r");
+  while((mpoint = getmntent(mtab)) != NULL)
+    if(!strcmp(mpoint->mnt_fsname, name))
+      {
+        endmntent(mtab);
+        statfs(mpoint->mnt_dir, &buf);
+        sprintf(size, "%lld M", (buf.f_bsize * (long long)buf.f_bfree) >> 20);
+        return size;
+      }
+  endmntent(mtab);
+  sprintf(size, "unkown");
+  return size;
+}
+
 static int parse_args(menu_t* menu,char* args) {
   char *element,*body, **attribs, *name, *ok, *cancel;
   list_entry_t* m = NULL;
@@ -75,7 +118,7 @@
     // Has it a name ?
     name = asx_get_attrib("name",attribs);
     opt = name ? m_config_get_option(mconfig,name) : NULL;
-    if(!opt) {
+    if(!opt && (!name || (strcmp(name, "ip") && !is_part(name)))) {
       printf("Pref menu entry definitions need a valid name attribut (line %d)\n",parser->line);
       free(element);
       if(name) free(name);
@@ -111,6 +154,7 @@
 
 static int openMenu(menu_t* menu, char* args) {
   list_entry_t* e;
+  char *txt;
 
   menu->draw = menu_list_draw;
   menu->read_cmd = menu_list_read_cmd;
@@ -129,15 +173,48 @@
 
   for(e = mpriv->p.menu ; e ; e = e->p.next) {
     int l;
-    char* val = m_option_print(e->opt,e->opt->p);
+    char* val = NULL;
+
+    if (e->opt)
+      val = m_option_print(e->opt,e->opt->p);
     if((int)val == -1) {
       printf("Can't get value of option %s\n",e->opt->name);
       continue;
-    } else if(!val)
-      val = strdup("NULL");
-    l = strlen(e->opt->name) + 2 + strlen(val) + 1;
+    } else if(!val) {
+      if (!strcmp(e->p.txt, "ip")) {
+        struct if_nameindex *ifs, *ifp;
+        struct ifreq ifr;
+        int fd, ip;
+
+        fd = socket(AF_INET, SOCK_DGRAM, 0);
+        if (fd >= 0) {
+          for (ifp = ifs = if_nameindex (); ifp->if_index != 0; ifp++) {
+            if (strcmp (ifp->if_name, "lo")) {
+              strcpy(ifr.ifr_name, ifp->if_name);
+              ifr.ifr_addr.sa_family = AF_INET;
+              if (ioctl(fd, SIOCGIFADDR, &ifr) == 0) {
+                val = (char *) malloc (16);
+                ip = ((struct sockaddr_in *) &ifr.ifr_addr)->sin_addr.s_addr;
+                sprintf (val, "%d.%d.%d.%d",
+                         ip&0xFF, (ip>>8)&0xFF, (ip>>16)&0xFF, (ip>>24)&0xFF);
+              } else {
+                val = strdup("NULL");
+              }
+              break;
+            }
+          }
+          if_freenameindex (ifs);
+          close (fd);
+        }
+      } else if (is_part(e->p.txt)) {
+        val = strdup(part_size(e->p.txt));
+      } else
+        val = strdup("NULL");
+    }
+    l = strlen(e->p.txt) + 2 + strlen(val) + 1;
+    txt = e->p.txt;
     e->p.txt = malloc(l);
-    sprintf(e->p.txt,"%s: %s",e->opt->name,val);
+    sprintf(e->p.txt,"%s: %s",txt,val);
     free(val);
   }    
 
