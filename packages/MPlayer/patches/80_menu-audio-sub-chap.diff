diff -Naur MPlayer-1.0pre6.orig/libmenu/Makefile MPlayer-1.0pre6/libmenu/Makefile
--- MPlayer-1.0pre6.orig/libmenu/Makefile	2004-12-30 19:38:06.756872496 +0100
+++ MPlayer-1.0pre6/libmenu/Makefile	2004-12-30 19:50:47.712189704 +0100
@@ -3,7 +3,7 @@
 
 LIBNAME = libmenu.a
 
-SRCS= menu.c vf_menu.c menu_cmdlist.c menu_pt.c menu_list.c menu_filesel.c menu_txt.c menu_console.c menu_param.c
+SRCS= menu.c vf_menu.c menu_cmdlist.c menu_pt.c menu_list.c menu_filesel.c menu_audiosel.c menu_subsel.c menu_chapsel.c menu_txt.c menu_console.c menu_param.c
 ifeq ($(DVBIN),yes)
 SRCS += menu_dvbin.c
 EXTRA_INC += $(DVB_INC)
diff -Naur MPlayer-1.0pre6.orig/libmenu/menu.c MPlayer-1.0pre6/libmenu/menu.c
--- MPlayer-1.0pre6.orig/libmenu/menu.c	2004-12-30 19:44:02.407805336 +0100
+++ MPlayer-1.0pre6/libmenu/menu.c	2004-12-30 19:50:47.713189552 +0100
@@ -25,6 +25,9 @@
 extern menu_info_t menu_info_cmdlist;
 extern menu_info_t menu_info_pt;
 extern menu_info_t menu_info_filesel;
+extern menu_info_t menu_info_audiosel;
+extern menu_info_t menu_info_subsel;
+extern menu_info_t menu_info_chapsel;
 extern menu_info_t menu_info_txt;
 extern menu_info_t menu_info_console;
 extern menu_info_t menu_info_pref;
@@ -37,6 +40,9 @@
   &menu_info_pt,
   &menu_info_cmdlist,
   &menu_info_filesel,
+  &menu_info_audiosel,
+  &menu_info_subsel,
+  &menu_info_chapsel,
   &menu_info_txt,
   &menu_info_console,
 #ifdef HAS_DVBIN_SUPPORT
diff -Naur MPlayer-1.0pre6.orig/libmenu/menu_audiosel.c MPlayer-1.0pre6/libmenu/menu_audiosel.c
--- MPlayer-1.0pre6.orig/libmenu/menu_audiosel.c	1970-01-01 01:00:00.000000000 +0100
+++ MPlayer-1.0pre6/libmenu/menu_audiosel.c	2004-12-30 19:50:47.713189552 +0100
@@ -0,0 +1,132 @@
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "../config.h"
+
+#include "../m_struct.h"
+#include "../m_option.h"
+#include "../input/input.h"
+
+#include "../libmpdemux/stream.h"
+#include "../libmpdemux/demuxer.h"
+
+#include "img_format.h"
+#include "mp_image.h"
+
+#include "menu.h"
+#include "menu_list.h"
+
+
+struct list_entry_s {
+  struct list_entry p;
+  int aid;
+};
+
+struct menu_priv_s {
+  menu_list_priv_t p;
+  char* title;
+  int auto_close;
+};
+
+static struct menu_priv_s cfg_dflt = {
+  MENU_LIST_PRIV_DFLT,
+  "Select audio channel",
+  0
+};
+
+#define ST_OFF(m) M_ST_OFF(struct menu_priv_s,m)
+
+static m_option_t cfg_fields[] = {
+  MENU_LIST_PRIV_FIELDS,
+  { "title", ST_OFF(title),  CONF_TYPE_STRING, 0, 0, 0, NULL },
+  { "auto-close", ST_OFF(auto_close), CONF_TYPE_FLAG, 0, 0, 1, NULL },
+  { NULL, NULL, NULL, 0,0,0,NULL }
+};
+
+
+extern stream_t* stream;
+extern demuxer_t *demuxer;
+extern void resync_audio_stream(void *sh_audio);
+extern char *dvd_lang_from_aid(stream_t *stream, int aid);
+
+static int fill_menu(menu_t* menu) {
+  char *str, aid_str[32];
+  list_entry_t* e;
+  int aid;
+
+  if (!demuxer || !demuxer->audio){
+    menu_list_read_cmd(menu,MENU_CMD_CANCEL);
+    return 1;
+  }
+
+  menu_list_init(menu);
+
+  for (aid=0; aid<MAX_A_STREAMS; aid++)
+    if (demuxer->a_streams[aid]){
+      if (stream->type == STREAMTYPE_DVD){
+        if (!(str = dvd_lang_from_aid(stream, aid)))
+          continue;
+        strcpy (aid_str, str);
+      } else
+        sprintf(aid_str, "%d", aid);
+      if((e = calloc(1,sizeof(list_entry_t))) != NULL){
+        e->p.next = NULL;
+        e->p.txt = strdup(aid_str);
+        e->aid = aid;
+        menu_list_add_entry(menu,e);
+      }
+    }
+
+  return 1;
+}
+
+static void read_cmd(menu_t* menu,int cmd) {
+  int aid;
+
+  switch(cmd) {
+  case MENU_CMD_OK:
+    aid = menu->priv->p.current->aid;
+    if (demuxer->audio->id != aid){
+      demuxer->audio->id = aid;
+      if(demuxer->audio->sh)
+        resync_audio_stream(demuxer->audio->sh);
+    }
+    if(menu->priv->auto_close)
+      mp_input_queue_cmd(mp_input_parse_cmd("menu hide"));
+    break;
+  default:
+    menu_list_read_cmd(menu,cmd);
+  }
+}
+
+static void close_as(menu_t* menu) {
+  menu_list_uninit(menu,NULL);
+}
+
+static int open_as(menu_t* menu, char* args) {
+  args = NULL;
+
+  menu->draw = menu_list_draw;
+  menu->read_cmd = read_cmd;
+  menu->read_key = menu_dflt_read_key;
+  menu->close = close_as;
+  menu->priv->p.title = menu->priv->title;
+
+  return fill_menu(menu);
+}
+  
+const menu_info_t menu_info_audiosel = {
+  "Audio seletor menu",
+  "audiosel",
+  "aurel.j",
+  "",
+  {
+    "audiosel_cfg",
+    sizeof(struct menu_priv_s),
+    &cfg_dflt,
+    cfg_fields
+  },
+  open_as
+};
diff -Naur MPlayer-1.0pre6.orig/libmenu/menu_chapsel.c MPlayer-1.0pre6/libmenu/menu_chapsel.c
--- MPlayer-1.0pre6.orig/libmenu/menu_chapsel.c	1970-01-01 01:00:00.000000000 +0100
+++ MPlayer-1.0pre6/libmenu/menu_chapsel.c	2004-12-30 19:50:47.713189552 +0100
@@ -0,0 +1,166 @@
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "../config.h"
+
+#include "../m_struct.h"
+#include "../m_option.h"
+#include "../input/input.h"
+
+#include "../libmpdemux/stream.h"
+#include "../libmpdemux/demuxer.h"
+#include "../libvo/video_out.h"
+#include "../libvo/sub.h"
+#include "../spudec.h"
+#include "../mplayer.h"
+
+#include "img_format.h"
+#include "mp_image.h"
+
+#include "menu.h"
+#include "menu_list.h"
+
+struct list_entry_s {
+  struct list_entry p;
+  int cid;
+};
+
+struct menu_priv_s {
+  menu_list_priv_t p;
+  char* title;
+  int auto_close;
+};
+
+static struct menu_priv_s cfg_dflt = {
+  MENU_LIST_PRIV_DFLT,
+  "Select chapter",
+  0
+};
+
+#define ST_OFF(m) M_ST_OFF(struct menu_priv_s,m)
+
+static m_option_t cfg_fields[] = {
+  MENU_LIST_PRIV_FIELDS,
+  { "title", ST_OFF (title),  CONF_TYPE_STRING, 0, 0, 0, NULL },
+  { "auto-close", ST_OFF (auto_close), CONF_TYPE_FLAG, 0, 0, 1, NULL },
+  { NULL, NULL, NULL, 0, 0, 0, NULL }
+};
+
+extern stream_t* stream;
+extern demuxer_t *demuxer;
+
+static int
+fill_menu (menu_t* menu)
+{
+  list_entry_t* e;
+  int cid;
+
+  if ((demuxer && stream->type == STREAMTYPE_DVD)
+      || (demuxer && demuxer->type == DEMUXER_TYPE_MATROSKA
+          && mkv_chapter_num > 0))
+    {
+      menu_list_init (menu);
+    
+      if (stream->type == STREAMTYPE_DVD)
+        {
+          for (cid = 1; cid < dvd_total_chapter + 1; cid++)
+            {
+              char *chap = malloc (3 * sizeof (char));
+              if ((e = calloc (1, sizeof (list_entry_t))) != NULL)
+                {
+                  sprintf (chap, "%d", cid);
+                  e->p.next = NULL;
+                  e->p.txt = strdup (chap);
+                  e->cid = cid;
+                  menu_list_add_entry (menu, e);
+                }
+              free (chap);
+            }
+        }
+      else if (demuxer->type == DEMUXER_TYPE_MATROSKA)
+        {
+          for (cid = 0; cid < mkv_chapter_num + 0; cid++)
+            {
+              if ((e = calloc (1, sizeof (list_entry_t))) != NULL)
+                {
+                  e->p.next = NULL;
+                  if (mkv_chapter_string[cid])
+                    e->p.txt = strdup (mkv_chapter_string[cid]);
+                  else
+                    {
+                      e->p.txt = malloc (4);
+                      sprintf (e->p.txt, "%-3d", cid+1);
+                    }
+                  e->cid = cid + 1;
+                  menu_list_add_entry (menu, e);
+                }
+            }
+        }
+    }
+  else
+    menu_list_read_cmd (menu, MENU_CMD_CANCEL);
+
+  return 1;
+}
+
+static void
+read_cmd (menu_t* menu, int cmd)
+{
+  switch (cmd)
+    {
+    case MENU_CMD_OK:
+      if (stream->type == STREAMTYPE_DVD)
+        {
+          stream_seek (stream,
+                       (off_t) dvd_chapter_pos[menu->priv->p.current->cid]
+                       * 2048);
+        }
+      else if (demuxer->type == DEMUXER_TYPE_MATROSKA)
+        {
+          demux_seek (demuxer,
+                      mkv_chapter_start[menu->priv->p.current->cid]/1000.0, 1);
+        }
+
+      if (menu->priv->auto_close)
+        mp_input_queue_cmd (mp_input_parse_cmd ("menu hide"));
+      break;
+    default:
+      menu_list_read_cmd (menu, cmd);
+    }
+}
+
+static void
+close_cs (menu_t* menu)
+{
+  menu_list_uninit (menu, NULL);
+}
+
+static int
+open_cs (menu_t* menu, char* args)
+{
+  args = NULL;
+
+  menu->draw = menu_list_draw;
+  menu->read_cmd = read_cmd;
+  menu->read_key = menu_dflt_read_key;
+  menu->close = close_cs;
+  menu->priv->p.title = menu->priv->title;
+
+  return fill_menu (menu);
+}
+  
+const menu_info_t menu_info_chapsel = {
+  "Chapter selector menu",
+  "chapsel",
+  "Benjamin Zores",
+  "",
+  {
+    "chapsel_cfg",
+    sizeof(struct menu_priv_s),
+    &cfg_dflt,
+    cfg_fields
+  },
+  open_cs
+};
diff -Naur MPlayer-1.0pre6.orig/libmenu/menu_subsel.c MPlayer-1.0pre6/libmenu/menu_subsel.c
--- MPlayer-1.0pre6.orig/libmenu/menu_subsel.c	1970-01-01 01:00:00.000000000 +0100
+++ MPlayer-1.0pre6/libmenu/menu_subsel.c	2004-12-30 19:50:47.714189400 +0100
@@ -0,0 +1,178 @@
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "../config.h"
+
+#include "../m_struct.h"
+#include "../m_option.h"
+#include "../input/input.h"
+
+#include "../libmpdemux/stream.h"
+#include "../libmpdemux/demuxer.h"
+#include "../libvo/video_out.h"
+#include "../libvo/sub.h"
+#include "../spudec.h"
+#include "../mplayer.h"
+
+#include "img_format.h"
+#include "mp_image.h"
+
+#include "menu.h"
+#include "menu_list.h"
+
+
+struct list_entry_s {
+  struct list_entry p;
+  int sid;
+};
+
+struct menu_priv_s {
+  menu_list_priv_t p;
+  char* title;
+  int auto_close;
+};
+
+static struct menu_priv_s cfg_dflt = {
+  MENU_LIST_PRIV_DFLT,
+  "Select subtitle",
+  0
+};
+
+#define ST_OFF(m) M_ST_OFF(struct menu_priv_s,m)
+
+static m_option_t cfg_fields[] = {
+  MENU_LIST_PRIV_FIELDS,
+  { "title", ST_OFF(title),  CONF_TYPE_STRING, 0, 0, 0, NULL },
+  { "auto-close", ST_OFF(auto_close), CONF_TYPE_FLAG, 0, 0, 1, NULL },
+  { NULL, NULL, NULL, 0,0,0,NULL }
+};
+
+
+extern stream_t* stream;
+extern demuxer_t *demuxer;
+
+static int fill_menu(menu_t* menu) {
+  list_entry_t* e;
+  char txt[3];
+  int lang, sid=0, inc;
+
+  if ((demuxer && demuxer->sub && stream->type == STREAMTYPE_DVD)
+      || (demuxer && demuxer->type == DEMUXER_TYPE_OGG && ogg_subtitles_num>0)
+      || (demuxer&&demuxer->type == DEMUXER_TYPE_MATROSKA&&mkv_subtitles_num>0)
+      || set_of_sub_size > 0){
+    menu_list_init(menu);
+
+    if(stream->type == STREAMTYPE_DVD){
+      while((lang = dvd_lang_from_sid(stream, sid)))
+        if((e = calloc(1,sizeof(list_entry_t))) != NULL){
+          txt[0] = lang>>8;
+          txt[1] = lang;
+          txt[2] = 0;
+          e->p.txt = strdup(txt);
+          e->p.next = NULL;
+          e->sid = sid++;
+          menu_list_add_entry(menu,e);
+        }
+    } else {
+      if(demuxer->type == DEMUXER_TYPE_OGG)
+        for(sid=0; sid<ogg_subtitles_num; sid++) {
+          if((e = calloc(1,sizeof(list_entry_t))) != NULL){
+            sprintf(txt, "%d\n", ogg_subtitles[sid]);
+            e->p.txt = strdup(txt);
+            e->p.next = NULL;
+            e->sid = sid;
+            menu_list_add_entry(menu,e);
+          }
+        }
+      else if(demuxer->type == DEMUXER_TYPE_MATROSKA)
+        for(sid=0; sid<mkv_subtitles_num; sid++) {
+          if((e = calloc(1,sizeof(list_entry_t))) != NULL){
+            sprintf(txt, "%d\n", mkv_subtitles[sid]);
+            e->p.txt = strdup(txt);
+            e->p.next = NULL;
+            e->sid = sid;
+            menu_list_add_entry(menu,e);
+          }
+        }
+      inc = sid;
+      sid = 0;
+      while(sid < set_of_sub_size)
+        if((e = calloc(1,sizeof(list_entry_t))) != NULL){
+          e->p.txt = strrchr(set_of_subtitles[sid]->filename, '/');
+          if(e->p.txt == NULL)  e->p.txt = set_of_subtitles[sid]->filename;
+          else  e->p.txt++;
+          e->p.next = NULL;
+          e->sid = inc + sid++;
+          menu_list_add_entry(menu,e);
+        }
+    }
+  } else {
+    menu_list_read_cmd(menu,MENU_CMD_CANCEL);
+  }
+
+  return 1;
+}
+
+static void read_cmd(menu_t* menu,int cmd) {
+  int sid;
+
+  switch(cmd) {
+  case MENU_CMD_OK:
+    sid = menu->priv->p.current->sid;
+    if(stream->type == STREAMTYPE_DVD && demuxer->sub->id != sid){
+      demuxer->sub->id = sid;
+      if(vo_spudec)
+        spudec_reset(vo_spudec);
+    } else if(demuxer->type == DEMUXER_TYPE_OGG && sid < ogg_subtitles_num) {
+      demuxer->sub->id = ogg_subtitles[sid];
+    } else if(demuxer->type==DEMUXER_TYPE_MATROSKA && sid<mkv_subtitles_num) {
+      demuxer->sub->id = mkv_subtitles[sid];
+    } else {
+      if (demuxer->type == DEMUXER_TYPE_OGG)
+        sid -= ogg_subtitles_num;
+      else if (demuxer->type == DEMUXER_TYPE_MATROSKA)
+        sid -= mkv_subtitles_num;
+      set_of_sub_pos = sid;
+      subdata = set_of_subtitles[set_of_sub_pos];
+      vo_sub = NULL;
+      vo_osd_changed(OSDTYPE_SUBTITLE);
+    }
+    if(menu->priv->auto_close)
+      mp_input_queue_cmd(mp_input_parse_cmd("menu hide"));
+    break;
+  default:
+    menu_list_read_cmd(menu,cmd);
+  }
+}
+
+static void close_ss(menu_t* menu) {
+  menu_list_uninit(menu,NULL);
+}
+
+static int open_ss(menu_t* menu, char* args) {
+  args = NULL;
+
+  menu->draw = menu_list_draw;
+  menu->read_cmd = read_cmd;
+  menu->read_key = menu_dflt_read_key;
+  menu->close = close_ss;
+  menu->priv->p.title = menu->priv->title;
+
+  return fill_menu(menu);
+}
+  
+const menu_info_t menu_info_subsel = {
+  "Subtitle seletor menu",
+  "subsel",
+  "aurel.j",
+  "",
+  {
+    "subsel_cfg",
+    sizeof(struct menu_priv_s),
+    &cfg_dflt,
+    cfg_fields
+  },
+  open_ss
+};
diff -Naur MPlayer-1.0pre6.orig/libmpdemux/demux_mkv.c MPlayer-1.0pre6/libmpdemux/demux_mkv.c
--- MPlayer-1.0pre6.orig/libmpdemux/demux_mkv.c	2004-12-30 19:38:06.769870520 +0100
+++ MPlayer-1.0pre6/libmpdemux/demux_mkv.c	2004-12-30 19:50:47.715189248 +0100
@@ -230,6 +230,11 @@
   uint32_t fourcc3;             /* fourcc */
 } real_audio_v5_props_t;
 
+int mkv_subtitles[64];
+int mkv_subtitles_num;
+uint64_t mkv_chapter_start[99];
+int mkv_chapter_num;
+char* mkv_chapter_string[99];
 
 /* for e.g. "-slang ger" */
 extern char *dvdsub_lang;
@@ -1340,6 +1345,35 @@
                               end = ebml_read_uint (s, &l) / 1000000;
                               break;
 
+                            case MATROSKA_ID_CHAPTERDISPLAY:
+                              {
+                                uint64_t len;
+                                int i;
+
+                                len = ebml_read_length (s, &i);
+                                l = len + i;
+
+                                while (len > 0)
+                                  {
+                                    uint64_t l;
+                                    int il;
+
+                                    switch (ebml_read_id (s, &il))
+                                      {
+                                      case MATROSKA_ID_CHAPTERSTRING:
+                                        mkv_chapter_string[mkv_chapter_num]
+                                          = ebml_read_utf8 (s, &l);
+                                        break;
+
+                                      default:
+                                        ebml_read_skip (s, &l);
+                                        break;
+                                      }
+                                    len -= l + il;
+                                  }
+                                break;
+                              }
+
                             default:
                               ebml_read_skip (s, &l);
                               break;
@@ -1361,6 +1395,8 @@
                              (int) ((end / 60 / 1000) % 60),
                              (int) ((end / 1000) % 60),
                              (int) (end % 1000));
+                      mkv_chapter_num = mkv_d->num_chapters;
+                      mkv_chapter_start[mkv_chapter_num] = start;
                       break;
                     }
 
@@ -2311,13 +2347,23 @@
     track = demux_mkv_find_track_by_num (mkv_d, demuxer->audio->id,
                                          MATROSKA_TRACK_AUDIO);
 
-  if (track && !demux_mkv_open_audio (demuxer, track))
+  if (track)
+     {
+       for (i=0; i < mkv_d->num_tracks; i++)
+         if (mkv_d->tracks[i]->type == MATROSKA_TRACK_AUDIO)
+           {
+             int def = (mkv_d->tracks[i] == track);
+             if (demux_mkv_open_audio (demuxer, mkv_d->tracks[i]) && def)
+               demuxer->audio->id = -2;
+             else if (def)
               {
                 mp_msg (MSGT_DEMUX, MSGL_INFO,
                         "[mkv] Will play audio track %u\n", track->tnum);
                 demuxer->audio->id = track->tnum;
                 demuxer->audio->sh = demuxer->a_streams[track->tnum];
               }
+           }
+     }
   else
     {
       mp_msg (MSGT_DEMUX, MSGL_INFO, "[mkv] No audio track found/wanted.\n");
@@ -2335,6 +2381,10 @@
     track = demux_mkv_find_track_by_language (mkv_d, dvdsub_lang,
                                               MATROSKA_TRACK_SUBTITLE);
 
+  mkv_subtitles_num = 0;
+  for (i=0; i < mkv_d->num_tracks; i++)
+    if (mkv_d->tracks[i]->type == MATROSKA_TRACK_SUBTITLE)
+      mkv_subtitles[mkv_subtitles_num++] = mkv_d->tracks[i]->tnum;
   if (track && !demux_mkv_open_sub (demuxer, track))
           {
             mp_msg (MSGT_DEMUX, MSGL_INFO,
@@ -2388,6 +2438,7 @@
 {
   mkv_demuxer_t *mkv_d = (mkv_demuxer_t *) demuxer->priv;
 
+  mkv_subtitles_num = 0;
   if (mkv_d)
     {
       int i;
diff -Naur MPlayer-1.0pre6.orig/libmpdemux/demux_ogg.c MPlayer-1.0pre6/libmpdemux/demux_ogg.c
--- MPlayer-1.0pre6.orig/libmpdemux/demux_ogg.c	2004-12-30 19:38:06.770870368 +0100
+++ MPlayer-1.0pre6/libmpdemux/demux_ogg.c	2004-12-30 19:50:47.716189096 +0100
@@ -164,6 +164,9 @@
 extern subtitle* vo_sub;
 static float clear_sub;
 //FILE* subout;
+int ogg_subtitles[64];
+int ogg_subtitles_num=0;
+
 
 static
 uint16_t get_uint16 (const void *buf)
@@ -748,6 +751,7 @@
 
   clear_sub = -1;
   s = demuxer->stream;
+  ogg_subtitles_num = 0;
 
   ogg_d = (ogg_demuxer_t*)calloc(1,sizeof(ogg_demuxer_t));
   sync = &ogg_d->sync;
@@ -994,6 +998,7 @@
 	/// Check for text (subtitles) header
       } else if (strncmp(st->streamtype, "text", 4) == 0) {
           mp_msg(MSGT_DEMUX, MSGL_V, "Ogg stream %d is text\n", ogg_d->num_sub);
+          ogg_subtitles[ogg_subtitles_num++] = ogg_d->num_sub;
 	  ogg_d->subs[ogg_d->num_sub].samplerate= get_uint64(&st->time_unit)/10;
 	  ogg_d->subs[ogg_d->num_sub].text = 1;
 	  if (identify)
@@ -1456,6 +1461,8 @@
   ogg_demuxer_t* ogg_d = demuxer->priv;
   int i;
 
+  ogg_subtitles_num = 0;
+
   if(!ogg_d)
     return;
 
diff -Naur MPlayer-1.0pre6.orig/libmpdemux/demuxer.h MPlayer-1.0pre6/libmpdemux/demuxer.h
--- MPlayer-1.0pre6.orig/libmpdemux/demuxer.h	2004-12-30 19:38:06.771870216 +0100
+++ MPlayer-1.0pre6/libmpdemux/demuxer.h	2004-12-30 19:50:47.716189096 +0100
@@ -268,6 +268,14 @@
 
 extern int extension_parsing;
 
+extern int ogg_subtitles[];
+extern int ogg_subtitles_num;
+extern int mkv_subtitles[];
+extern int mkv_subtitles_num;
+extern int mkv_chapter_num;
+extern uint64_t mkv_chapter_start[99];
+extern char* mkv_chapter_string[99];
+
 int demux_info_add(demuxer_t *demuxer, char *opt, char *param);
 char* demux_info_get(demuxer_t *demuxer, char *opt);
 int demux_info_print(demuxer_t *demuxer);
diff -Naur MPlayer-1.0pre6.orig/libmpdemux/ebml.h MPlayer-1.0pre6/libmpdemux/ebml.h
--- MPlayer-1.0pre6.orig/libmpdemux/ebml.h	2004-12-30 19:38:06.772870064 +0100
+++ MPlayer-1.0pre6/libmpdemux/ebml.h	2004-12-30 19:50:47.716189096 +0100
@@ -128,6 +128,8 @@
 #define MATROSKA_ID_CHAPTERATOM          0xB6
 #define MATROSKA_ID_CHAPTERTIMESTART     0x91
 #define MATROSKA_ID_CHAPTERTIMEEND       0x92
+#define MATROSKA_ID_CHAPTERDISPLAY       0x80
+#define MATROSKA_ID_CHAPTERSTRING        0x85
 
 /* IDs in the cluster master */
 #define MATROSKA_ID_CLUSTERTIMECODE      0xE7
diff -Naur MPlayer-1.0pre6.orig/libmpdemux/open.c MPlayer-1.0pre6/libmpdemux/open.c
--- MPlayer-1.0pre6.orig/libmpdemux/open.c	2004-12-30 19:45:55.763572640 +0100
+++ MPlayer-1.0pre6/libmpdemux/open.c	2004-12-30 19:50:47.717188944 +0100
@@ -36,6 +36,8 @@
 
 int dvd_chapter=1;
 int dvd_last_chapter=0;
+int dvd_total_chapter=0;
+int dvd_chapter_pos[99];
 int dvd_angle=1;
 char* dvd_device=NULL;
 char* cdrom_device=NULL;
@@ -364,6 +366,7 @@
      */
     mp_msg(MSGT_OPEN,MSGL_INFO, MSGTR_DVDnumChapters,
              tt_srpt->title[dvd_title].nr_of_ptts );
+    dvd_total_chapter = tt_srpt->title[dvd_title].nr_of_ptts;
     if( dvd_chapter<1 || dvd_chapter>tt_srpt->title[dvd_title].nr_of_ptts ) {
 	mp_msg(MSGT_OPEN,MSGL_ERR, MSGTR_DVDinvalidChapter, dvd_chapter);
         ifoClose( vmg_file );
@@ -565,6 +568,10 @@
     d->cell_last_pack=d->cur_pgc->cell_playback[ d->cur_cell ].last_sector;
     mp_msg(MSGT_DVD,MSGL_V, "DVD start cell: %d  pack: 0x%X-0x%X  \n",d->cur_cell,d->cur_pack,d->cell_last_pack);
 
+    int chap;
+    for (chap = 0; chap < dvd_total_chapter; chap++)
+      dvd_chapter_pos[chap+1] = d->cur_pgc->cell_playback[chap].first_sector;
+
     // ... (unimplemented)
 //    return NULL;
   stream=new_stream(-1,STREAMTYPE_DVD);
@@ -777,6 +784,19 @@
   return d->subtitles[id].language;
 }
 
+char *dvd_lang_from_aid(stream_t *stream, int aid){
+static char desc[32];
+dvd_priv_t *d=stream->priv;
+int i;
+  for(i=0;i<d->nr_of_channels;i++){
+    if(d->audio_streams[i].id==aid){
+      sprintf (desc, "%c%c - %s (%s)", (d->audio_streams[i].language>>8)&0xFF, d->audio_streams[i].language&0xFF, dvd_audio_stream_types[d->audio_streams[i].type], dvd_audio_stream_channels[d->audio_streams[i].channels]);
+      return desc;
+    }
+  }
+  return NULL;
+}
+
 int dvd_sid_from_lang(stream_t *stream, unsigned char* lang){
 dvd_priv_t *d=stream->priv;
 int code,i;
diff -Naur MPlayer-1.0pre6.orig/libmpdemux/stream.h MPlayer-1.0pre6/libmpdemux/stream.h
--- MPlayer-1.0pre6.orig/libmpdemux/stream.h	2004-12-30 19:38:06.774869760 +0100
+++ MPlayer-1.0pre6/libmpdemux/stream.h	2004-12-30 19:50:47.717188944 +0100
@@ -257,6 +257,8 @@
 extern int dvd_title;
 extern int dvd_chapter;
 extern int dvd_last_chapter;
+extern int dvd_total_chapter;
+extern int dvd_chapter_pos[99];
 extern int dvd_angle;
 //#endif
 
diff -Naur MPlayer-1.0pre6.orig/mplayer.c MPlayer-1.0pre6/mplayer.c
--- MPlayer-1.0pre6.orig/mplayer.c	2004-12-30 19:46:23.841304176 +0100
+++ MPlayer-1.0pre6/mplayer.c	2004-12-30 19:50:47.719188640 +0100
@@ -323,8 +323,8 @@
 int global_sub_indices[SUB_SOURCES];
 int global_sub_quiet_osd_hack = 0;
 
-static stream_t* stream=NULL;
-static demuxer_t *demuxer=NULL;
+stream_t* stream=NULL;
+demuxer_t *demuxer=NULL;
 static sh_audio_t *sh_audio=NULL;
 static sh_video_t *sh_video=NULL;
 
@@ -1845,8 +1845,7 @@
 
 //================== Read SUBTITLES (DVD & TEXT) ==========================
 if(vo_spudec==NULL && sh_video &&
-     (stream->type==STREAMTYPE_DVD || demuxer->type==DEMUXER_TYPE_MATROSKA ||
-      d_dvdsub->id >= 0)){
+     (stream->type==STREAMTYPE_DVD || demuxer->type==DEMUXER_TYPE_MATROSKA)){
 
 if (spudec_ifo) {
   unsigned int palette[16], width, height;
diff -Naur MPlayer-1.0pre6.orig/mplayer.h MPlayer-1.0pre6/mplayer.h
--- MPlayer-1.0pre6.orig/mplayer.h	2004-12-30 19:46:23.842304024 +0100
+++ MPlayer-1.0pre6/mplayer.h	2004-12-30 19:50:47.719188640 +0100
@@ -36,6 +36,9 @@
 extern int    sub_unicode;
 extern char * sub_cp;
 extern sub_data* subdata; //currently used subtitles  
+extern sub_data* set_of_subtitles[MAX_SUBTITLE_FILES];
+extern int set_of_sub_size;
+extern int set_of_sub_pos;
 extern subtitle* vo_sub;
 extern int    suboverlap_enabled;
 
