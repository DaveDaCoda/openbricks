--- lirc-0.7.1.orig/drivers/lirc_it87lirc_it87.c	2005-02-19 23:13:01.000000000 +0800
+++ lirc-0.7.1/drivers/lirc_it87/lirc_it87.c	2005-06-05 00:01:22.753945064 +0800
@@ -25,6 +25,9 @@
  *
  * 2001/02/27 Christoph Bartelmus <lirc@bartelmus.de> :
  *   reimplemented read function
+ * 2005/06/05 Andrew Calkin implemented support for Asus Digimatrix,
+ *   based on work of the following member of the Outertrack Digimatrix 
+ *   Forum: Art103 <r_tay@hotmail.com>
  */
 
 
@@ -68,6 +71,10 @@
 
 #include "lirc_it87.h"
 
+/* Assume not Asus Digimatrix it87 */
+static int dmtx = 0;
+static int it87_freq = 38; /* kHz */
+
 static unsigned long it87_bits_in_byte_out = 0;
 static unsigned long it87_send_counter = 0;
 static unsigned char it87_RXEN_mask = IT87_CIR_RCR_RXEN;
@@ -91,7 +98,6 @@
 
 static int io = IT87_CIR_DEFAULT_IOBASE;
 static int irq = IT87_CIR_DEFAULT_IRQ;
-static unsigned char it87_freq = 38; /* kHz */
 /* receiver demodulator default: off */
 static int it87_enable_demodulator = 0;
 
@@ -102,6 +108,7 @@
 /* time of last UART data ready interrupt */
 static struct timeval last_intr_tv = {0, 0};
 static int last_value = 0;
+static int lastbit = 0;
 
 static DECLARE_WAIT_QUEUE_HEAD(lirc_read_queue);
 
@@ -442,6 +449,7 @@
 	return deltv;
 }
 
+static int timer_enabled = 0;
 
 static void it87_timeout(unsigned long data) 
 {
@@ -453,21 +461,46 @@
 	unsigned long flags;
 	unsigned long pulse_end;
 	
+	/* We have timed out.
+	   Disable the RX mechanism.
+	*/
+	
 	/* avoid interference with interrupt */
  	spin_lock_irqsave(&timer_lock, flags);
-	if (last_value) {
-		/* determine 'virtual' pulse end: */
-	 	pulse_end = delta(&last_tv, &last_intr_tv);
-		dprintk("timeout add %d for %lu usec\n", 
-			last_value, pulse_end);
-		add_read_queue(last_value,
-			       pulse_end);
-		last_value = 0;
-		last_tv=last_intr_tv;
+ 	if (dmtx) {
+        outb((inb(io + IT87_CIR_RCR) & ~IT87_CIR_RCR_RXEN) |
+            IT87_CIR_RCR_RXACT,
+            io + IT87_CIR_RCR);
+        if (it87_RXEN_mask) {
+            outb(inb(io + IT87_CIR_RCR) | IT87_CIR_RCR_RXEN,
+                io + IT87_CIR_RCR);
+        }
+        dprintk(" TIMEOUT\n");
+        timer_enabled = 0;
+
+        /* fifo clear */
+        outb(inb(io + IT87_CIR_TCR1) | IT87_CIR_TCR1_FIFOCLR,
+        io+IT87_CIR_TCR1);
+
+    }
+	else {
+		if (last_value) {
+			/* determine 'virtual' pulse end: */
+	 		pulse_end = delta(&last_tv, &last_intr_tv);
+			dprintk("timeout add %d for %lu usec\n", 
+				last_value, pulse_end);
+			add_read_queue(last_value,
+				       pulse_end);
+			last_value = 0;
+			last_tv=last_intr_tv;
+		}
 	}
 	spin_unlock_irqrestore(&timer_lock, flags);		
+
 }
 
+static unsigned long acc_pulse = 0;
+static unsigned long acc_space = 0;
 
 static irqreturn_t it87_interrupt(int irq,
 				 void * dev_id,
@@ -480,6 +513,15 @@
 	unsigned long flags, hw_flags;
 	int iir, lsr;
 	int fifo = 0;
+    int pos_flank = 0;
+    int neg_flank = 0;
+    static char lastbit = 0;
+    char bit;
+
+    //Bit duration in microseconds
+    const unsigned long bit_duration = 1000000ul / 
+       (115200 / IT87_CIR_BAUDRATE_DIVISOR);
+
 
 	iir = inb(io + IT87_CIR_IIR);
 
@@ -494,67 +536,109 @@
 		/* avoid interference with timer */
 		spin_lock_irqsave(&timer_lock, flags);
 		spin_lock_irqsave(&hardware_lock, hw_flags);
-		do {
-			del_timer(&timerlist);
-			data = inb(io + IT87_CIR_DR);
-
-			dprintk("data=%.2x\n", data);
-			do_gettimeofday(&curr_tv);
-			deltv = delta(&last_tv, &curr_tv);
-			deltintrtv = delta(&last_intr_tv, &curr_tv);
+		if (dmtx) { 
+			do {
+	            data = inb(io + IT87_CIR_DR);
+    	        data =~ data;
+        	    fifo--;
+            	if (data != 0x00) {
+	                if (timer_enabled) {
+    	            	del_timer(&timerlist);
+					}
+                	/* start timer for end of sequence detection */
+	                timerlist.expires = jiffies + IT87_TIMEOUT;
+    	            add_timer(&timerlist);
+        	        timer_enabled = 1;
+            	}
+	           // Loop through 
+    	       for(bit = 0; bit < 8; ++bit)
+        	   {
+            	    if((data >> bit) & 1)
+	               		{
+    	                ++acc_pulse;
+        	            if(lastbit == 0)
+            		    	{
+                       		add_read_queue(0, acc_space * bit_duration);
+                       		acc_space = 0;
+				            }
+        				}
+	               else
+    	           {
+        	           ++acc_space;
+            	       if(lastbit == 1)
+                		   {
+                    		add_read_queue(1, acc_pulse * bit_duration);
+	                       acc_pulse = 0;
+    		               }
+            	    }
+					lastbit = (data >> bit) & 1;
+	           }
+
+    	   } while (fifo != 0);
+	 	}
+		else {/* Normal Operation */
+			do {
+				del_timer(&timerlist);
+				data = inb(io + IT87_CIR_DR);
+
+				dprintk("data=%.2x\n", data);
+				do_gettimeofday(&curr_tv);
+				deltv = delta(&last_tv, &curr_tv);
+				deltintrtv = delta(&last_intr_tv, &curr_tv);
 
-			dprintk("t %lu , d %d\n", deltintrtv, (int)data);
+				dprintk("t %lu , d %d\n", deltintrtv, (int)data);
 			
-			/* if nothing came in last 2 cycles,
-			   it was gap */
-			if (deltintrtv > TIME_CONST * 2) {
-				if (last_value) {
-					dprintk("GAP\n");
-
-					/* simulate signal change */
-					add_read_queue(last_value,
-						       deltv-
-						       deltintrtv);
-					last_value = 0;
-					last_tv.tv_sec = last_intr_tv.tv_sec;
-					last_tv.tv_usec = last_intr_tv.tv_usec;
-					deltv = deltintrtv;
+				/* if nothing came in last 2 cycles,
+				   it was gap */
+				if (deltintrtv > TIME_CONST * 2) {
+					if (last_value) {
+						dprintk("GAP\n");
+
+						/* simulate signal change */
+						add_read_queue(last_value,
+							       deltv-
+							       deltintrtv);
+						last_value = 0;
+						last_tv.tv_sec = last_intr_tv.tv_sec;
+						last_tv.tv_usec = last_intr_tv.tv_usec;
+						deltv = deltintrtv;
+					}
 				}
-			}
-			data = 1;
-			if (data ^ last_value) {
-				/* deltintrtv > 2*TIME_CONST,
-				   remember ? */
-				/* the other case is timeout */
-				add_read_queue(last_value,
-					       deltv-TIME_CONST);
-				last_value = data;
-				last_tv = curr_tv;
-				if(last_tv.tv_usec>=TIME_CONST) {
-					last_tv.tv_usec-=TIME_CONST;
+				data = 1;
+				if (data ^ last_value) {
+					/* deltintrtv > 2*TIME_CONST,
+					   remember ? */
+					/* the other case is timeout */
+					add_read_queue(last_value,
+						       deltv-TIME_CONST);
+					last_value = data;
+					last_tv = curr_tv;
+					if(last_tv.tv_usec>=TIME_CONST) {
+						last_tv.tv_usec-=TIME_CONST;
+					}
+					else {
+						last_tv.tv_sec--;
+						last_tv.tv_usec+=1000000-
+							TIME_CONST;
+					}
 				}
-				else {
-					last_tv.tv_sec--;
-					last_tv.tv_usec+=1000000-
-						TIME_CONST;
+				last_intr_tv = curr_tv;
+				if (data) {
+					/* start timer for end of sequence detection */
+					timerlist.expires = jiffies + IT87_TIMEOUT;
+					add_timer(&timerlist);
 				}
-			}
-			last_intr_tv = curr_tv;
-			if (data) {
-				/* start timer for end of sequence detection */
-				timerlist.expires = jiffies + IT87_TIMEOUT;
-				add_timer(&timerlist);
-			}
-			outb((inb(io + IT87_CIR_RCR) & ~IT87_CIR_RCR_RXEN) |
-			     IT87_CIR_RCR_RXACT,
-			     io + IT87_CIR_RCR);
-			if (it87_RXEN_mask) {
-				outb(inb(io + IT87_CIR_RCR) | IT87_CIR_RCR_RXEN, 
+				outb((inb(io + IT87_CIR_RCR) & ~IT87_CIR_RCR_RXEN) |
+				     IT87_CIR_RCR_RXACT,
 				     io + IT87_CIR_RCR);
-			}
-			fifo--;
+				if (it87_RXEN_mask) {
+					outb(inb(io + IT87_CIR_RCR) | IT87_CIR_RCR_RXEN, 
+					     io + IT87_CIR_RCR);
+						}
+				fifo--;
+				}
+			while (fifo != 0);
 		}
-		while (fifo != 0);
 		spin_unlock_irqrestore(&hardware_lock, hw_flags);
 		spin_unlock_irqrestore(&timer_lock, flags);
 		
@@ -681,15 +765,33 @@
 	outb(IT87_CIR_BAUDRATE_DIVISOR % 0x100, io+IT87_CIR_BDLR);
 	outb(IT87_CIR_BAUDRATE_DIVISOR / 0x100, io+IT87_CIR_BDHR);
 	/* Baudrate Register off, define IRQs: Input only */
-	outb(IT87_CIR_IER_IEC | IT87_CIR_IER_RDAIE, io + IT87_CIR_IER);
-	/* RX: HCFS=0, RXDCR = 001b (35,6..40,3 kHz), RXEN=1 */
+	if (dmtx) {
+	outb(IT87_CIR_IER_IEC | IT87_CIR_IER_RFOIE, io + IT87_CIR_IER);
+	/* RX: HCFS=0, RXDCR = 001b (33,75..38,25 kHz), RXEN=1 */
+	}
+	else {
+		outb(IT87_CIR_IER_IEC | IT87_CIR_IER_RDAIE, io + IT87_CIR_IER);
+		/* RX: HCFS=0, RXDCR = 001b (35,6..40,3 kHz), RXEN=1 */
+	}
 	it87_rcr = (IT87_CIR_RCR_RXEN & it87_RXEN_mask) | 0x1;
 	if (it87_enable_demodulator)
 		it87_rcr |= IT87_CIR_RCR_RXEND;
 	outb(it87_rcr, io + IT87_CIR_RCR);
-	/* TX: 38kHz, 13,3us (pulse-width */
-	outb(((it87_freq - IT87_CIR_FREQ_MIN) << 3) | 0x06,
-	     io + IT87_CIR_TCR2);
+	if (dmtx) {
+		// Set FIFO depth to 1 byte, and disable TX
+		outb(inb(io + IT87_CIR_TCR1) |
+		0x00,
+		io + IT87_CIR_TCR1);
+
+		/* TX: it87_freq (36kHz), 'reserved' sensitivity setting (0x00) */
+		outb(((it87_freq - IT87_CIR_FREQ_MIN) << 3) | 0x00,
+			io + IT87_CIR_TCR2);
+	}
+	else {
+		/* TX: 38kHz, 13,3us (pulse-width */
+		outb(((it87_freq - IT87_CIR_FREQ_MIN) << 3) | 0x06,
+		     io + IT87_CIR_TCR2);
+	}
 	spin_unlock_irqrestore(&hardware_lock, flags);
 	return 0;
 }
@@ -797,6 +899,10 @@
 	}
 	else
 		irq = it87_irq;
+	if (dmtx) {
+		irq = 0x09;
+		it87_write(IT87_CIR_IRQ, irq);
+	}	
 	
 	{
 		unsigned long hw_flags;
@@ -933,6 +1039,14 @@
 module_param(debug, bool, 0644);
 MODULE_PARM_DESC(debug, "Enable debugging messages");
 
+module_param(dmtx, bool, 0644);
+MODULE_PARM_DESC(dmtx, 
+	"Asus Digimatrix it87 compat. enable/disable (1/0), default: 0");
+
+module_param(it87_freq, int, 0444);
+MODULE_PARM_DESC(it87_freq,
+    "Carrier demodulator frequency (kHz), (default: 38)");
+
 EXPORT_NO_SYMBOLS;
 
 #endif /* MODULE */
