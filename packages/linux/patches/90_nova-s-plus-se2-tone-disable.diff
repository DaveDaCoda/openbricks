diff -Naur linux-2.6.16.11.orig/drivers/media/dvb/frontends/cx24123.c linux-2.6.16.11/drivers/media/dvb/frontends/cx24123.c
--- linux-2.6.16.11.orig/drivers/media/dvb/frontends/cx24123.c	2006-04-29 13:22:17.000000000 +0200
+++ linux-2.6.16.11/drivers/media/dvb/frontends/cx24123.c	2006-04-29 13:20:39.000000000 +0200
@@ -29,7 +29,7 @@
 #include "dvb_frontend.h"
 #include "cx24123.h"
 
-static int debug;
+static int debug = 0;
 #define dprintk(args...) \
 	do { \
 		if (debug) printk (KERN_DEBUG "cx24123: " args); \
@@ -252,6 +252,22 @@
 	{0x67, 0x83},
 };
 
+/*
+ 
+    0x29:
+	0x01	
+	0x02
+	0x04
+
+		40=A	48=B
+		41=ML4
+		42=ML5
+		43=ML6
+	0x10	1=tone on   0=tone off
+	0x80	1=13V	    0=18V
+
+    0x2a:
+ */
 static int cx24123_writereg(struct cx24123_state* state, int reg, int data)
 {
 	u8 buf[] = { reg, data };
@@ -624,13 +640,112 @@
 	return 0;
 }
 
-static int cx24123_send_diseqc_msg(struct dvb_frontend* fe,
-				   struct dvb_diseqc_master_cmd *cmd)
+static int cx24123_diseqc_send_burst(struct dvb_frontend* fe, fe_sec_mini_cmd_t burst)
+{
+	struct cx24123_state *state = fe->demodulator_priv;
+	int val, tone, org_val;
+	unsigned long timeout;
+
+	return(0);
+	dprintk("%s:\n", __FUNCTION__);
+    
+	msleep(30);
+	org_val = cx24123_readreg(state, 0x2a);
+	val = org_val & 0xf8;
+
+	if (state->config->use_isl6421) {
+		tone = cx24123_readlnbreg(state, 0x00);
+		printk("6421: TONE-BURST burst=%s\n", 
+			(burst == SEC_MINI_A) ? "A" : "B");
+		/*
+		printk("6421: TONE-BURST, 0x2a=0x%02x tone=0x%02x burst=%s\n", 
+			org_val, tone, (burst == SEC_MINI_A) ? "A" : "B");
+		*/
+		/* check if continuous tone has been stoped */
+		tone = tone & 0x10;
+		if (tone) {
+			printk("%s: ERROR: attempt to send diseqc command before tone is off\n", __FUNCTION__);
+			return -ENOTSUPP;
+		}
+
+		/* select envelope mode because an external tone generator is used */
+		cx24123_writereg(state, 0x2a, (val | 0x04) | 0x02);
+	} else {
+		/* check if continuous tone has been stoped */
+		tone = cx24123_readreg(state, 0x29) & 0x10;
+		if (tone) {
+			printk("%s: ERROR: attempt to send diseqc command before tone is off\n", __FUNCTION__);
+			return -ENOTSUPP;
+		}
+
+		/* select tone mode, bits 0-1 already set to 0 */
+		cx24123_writereg(state, 0x2a, val | 0x04);
+	}
+	msleep(30);
+
+	val = cx24123_readreg(state, 0x29);
+
+	if (burst == SEC_MINI_A)
+		cx24123_writereg(state, 0x29, ((val & 0x90) | 0x40 | 0x00));
+	else if (burst == SEC_MINI_B)
+		cx24123_writereg(state, 0x29, ((val & 0x90) | 0x40 | 0x08));
+	else
+		return -EINVAL;
+
+
+	timeout = jiffies + msecs_to_jiffies(100);
+	while (!time_after(jiffies, timeout)) {
+	    int	v = cx24123_readreg(state, 0x29);
+	    printk("V=%02x\n",v);
+	    if (!(v&0x40))
+		break;
+	}
+		; // wait for LNB ready
+
+	msleep(30);
+	return 0;
+}
+
+static int cx24123_send_diseqc_msg(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)
 {
-	/* fixme: Implement diseqc */
-	printk("%s: No support yet\n",__FUNCTION__);
+	struct cx24123_state *state = fe->demodulator_priv;
+	int i, org_val, val02 = 0xff, val00, val01, val, tone;
+	unsigned long timeout;
+
+	dprintk("%s:\n",__FUNCTION__);
 
-	return -ENOTSUPP;
+	/* V002
+	val = cx24123_readlnbreg(state, 0x0);
+	cx24123_writelnbreg(state, 0x0, val | 0x10);
+	msleep(200);
+	cx24123_writelnbreg(state, 0x0, val & 0xef);
+	cx24123_writereg(state, 0x2a, 0xb0);
+	msleep(200);
+	*/
+
+	cx24123_writereg(state, 0x29, 0x00);
+	val00 = cx24123_readreg(state, 0x29);
+	for (i = 0; i < cmd->msg_len; i++)
+		cx24123_writereg(state, 0x2C + i, cmd->msg[i]);
+	cx24123_writereg(state, 0x29, 0x40 | ((cmd->msg_len-3) & 3));
+
+	// msleep(30);
+
+	val01 = cx24123_readreg(state, 0x29);
+
+	/* V001
+	for (i = 0; i < cmd->msg_len; i++)
+		cx24123_writereg(state, 0x2C + i, cmd->msg[i]);
+	cx24123_writereg(state, 0x29, 0x40 | ((cmd->msg_len-3) & 3));
+	val02 = cx24123_readreg(state, 0x29);
+	*/
+
+	timeout = jiffies + msecs_to_jiffies(200);
+	while (!time_after(jiffies, timeout) && !(cx24123_readreg(state, 0x29) & 0x40))
+		; // wait for LNB ready
+	val = cx24123_readreg(state, 0x29);
+	// printk("RDY(0x29): %02x %02x %02x %02x (0x2a): %02x\n", val00, val01, val02, val, cx24123_readreg(state, 0x2a));
+	return 0;
 }
 
 static int cx24123_read_status(struct dvb_frontend* fe, fe_status_t* status)
@@ -763,8 +878,12 @@
 
 		switch (tone) {
 		case SEC_TONE_ON:
+			return(0);
+			printk("6421: set_tone: ON\n");
 			return cx24123_writelnbreg(state, 0x0, val | 0x10);
 		case SEC_TONE_OFF:
+			return(0);
+			printk("6421: set_tone: OFF\n");
 			return cx24123_writelnbreg(state, 0x0, val & 0x2f);
 		default:
 			printk("%s: CASE reached default with tone=%d\n", __FUNCTION__, tone);
@@ -875,6 +994,7 @@
 	.read_snr = cx24123_read_snr,
 	.read_ucblocks = cx24123_read_ucblocks,
 	.diseqc_send_master_cmd = cx24123_send_diseqc_msg,
+	.diseqc_send_burst = cx24123_diseqc_send_burst,
 	.set_tone = cx24123_set_tone,
 	.set_voltage = cx24123_set_voltage,
 };

