diff -Naur linux-2.6.16.17.orig/drivers/media/dvb/frontends/cx24123.c linux-2.6.16.17/drivers/media/dvb/frontends/cx24123.c
--- linux-2.6.16.17.orig/drivers/media/dvb/frontends/cx24123.c	2006-05-21 00:00:46.000000000 +0200
+++ linux-2.6.16.17/drivers/media/dvb/frontends/cx24123.c	2006-06-17 23:32:34.000000000 +0200
@@ -29,6 +29,9 @@
 #include "dvb_frontend.h"
 #include "cx24123.h"
 
+#define XTAL 10111000
+
+static int force_band;
 static int debug;
 #define dprintk(args...) \
 	do { \
@@ -52,6 +55,7 @@
 	u32 VGAarg;
 	u32 bandselectarg;
 	u32 pllarg;
+	u32 FILTune;
 
 	/* The Demod/Tuner can't easily provide these, we cache them */
 	u32 currentfreq;
@@ -63,43 +67,33 @@
 {
 	u32 symbolrate_low;
 	u32 symbolrate_high;
-	u32 VCAslope;
-	u32 VCAoffset;
-	u32 VGA1offset;
-	u32 VGA2offset;
 	u32 VCAprogdata;
 	u32 VGAprogdata;
+	u32 FILTune;
 } cx24123_AGC_vals[] =
 {
 	{
 		.symbolrate_low		= 1000000,
 		.symbolrate_high	= 4999999,
-		.VCAslope		= 0x07,
-		.VCAoffset		= 0x0f,
-		.VGA1offset		= 0x1f8,
-		.VGA2offset		= 0x1f8,
-		.VGAprogdata		= (2 << 18) | (0x1f8 << 9) | 0x1f8,
-		.VCAprogdata		= (4 << 18) | (0x07 << 9) | 0x07,
+		/* the specs recommend other values for VGA offsets,
+		   but tests show they are wrong */
+		.VGAprogdata		= (1 << 19) | (0x180 << 9) | 0x1e0,
+		.VCAprogdata		= (2 << 19) | (0x07 << 9) | 0x07,
+		.FILTune		= 0x27f /* 0.41 V */
 	},
 	{
 		.symbolrate_low		=  5000000,
 		.symbolrate_high	= 14999999,
-		.VCAslope		= 0x1f,
-		.VCAoffset		= 0x1f,
-		.VGA1offset		= 0x1e0,
-		.VGA2offset		= 0x180,
-		.VGAprogdata		= (2 << 18) | (0x180 << 9) | 0x1e0,
-		.VCAprogdata		= (4 << 18) | (0x07 << 9) | 0x1f,
+		.VGAprogdata		= (1 << 19) | (0x180 << 9) | 0x1e0,
+		.VCAprogdata		= (2 << 19) | (0x07 << 9) | 0x1f,
+		.FILTune		= 0x317 /* 0.90 V */
 	},
 	{
 		.symbolrate_low		= 15000000,
 		.symbolrate_high	= 45000000,
-		.VCAslope		= 0x3f,
-		.VCAoffset		= 0x3f,
-		.VGA1offset		= 0x180,
-		.VGA2offset		= 0x100,
-		.VGAprogdata		= (2 << 18) | (0x100 << 9) | 0x180,
-		.VCAprogdata		= (4 << 18) | (0x07 << 9) | 0x3f,
+		.VGAprogdata		= (1 << 19) | (0x100 << 9) | 0x180,
+		.VCAprogdata		= (2 << 19) | (0x07 << 9) | 0x3f,
+		.FILTune		= 0x145 /* 2.70 V */
 	},
 };
 
@@ -112,91 +106,80 @@
 {
 	u32 freq_low;
 	u32 freq_high;
-	u32 bandselect;
 	u32 VCOdivider;
-	u32 VCOnumber;
 	u32 progdata;
 } cx24123_bandselect_vals[] =
 {
+	/* band 1 */
 	{
 		.freq_low	= 950000,
-		.freq_high	= 1018999,
-		.bandselect	= 0x40,
-		.VCOdivider	= 4,
-		.VCOnumber	= 7,
-		.progdata	= (0 << 18) | (0 << 9) | 0x40,
-	},
-	{
-		.freq_low	= 1019000,
 		.freq_high	= 1074999,
-		.bandselect	= 0x80,
 		.VCOdivider	= 4,
-		.VCOnumber	= 8,
-		.progdata	= (0 << 18) | (0 << 9) | 0x80,
+		.progdata	= (0 << 19) | (0 << 9) | 0x40,
 	},
+
+	/* band 2 */
 	{
 		.freq_low	= 1075000,
-		.freq_high	= 1227999,
-		.bandselect	= 0x01,
-		.VCOdivider	= 2,
-		.VCOnumber	= 1,
-		.progdata	= (0 << 18) | (1 << 9) | 0x01,
+		.freq_high	= 1177999,
+		.VCOdivider	= 4,
+		.progdata	= (0 << 19) | (0 << 9) | 0x80,
 	},
+
+	/* band 3 */
 	{
-		.freq_low	= 1228000,
-		.freq_high	= 1349999,
-		.bandselect	= 0x02,
+		.freq_low	= 1178000,
+		.freq_high	= 1295999,
 		.VCOdivider	= 2,
-		.VCOnumber	= 2,
-		.progdata	= (0 << 18) | (1 << 9) | 0x02,
+		.progdata	= (0 << 19) | (1 << 9) | 0x01,
 	},
+
+	/* band 4 */
 	{
-		.freq_low	= 1350000,
-		.freq_high	= 1481999,
-		.bandselect	= 0x04,
+		.freq_low	= 1296000,
+		.freq_high	= 1431999,
 		.VCOdivider	= 2,
-		.VCOnumber	= 3,
-		.progdata	= (0 << 18) | (1 << 9) | 0x04,
+		.progdata	= (0 << 19) | (1 << 9) | 0x02,
 	},
+
+	/* band 5 */
 	{
-		.freq_low	= 1482000,
-		.freq_high	= 1595999,
-		.bandselect	= 0x08,
+		.freq_low	= 1432000,
+		.freq_high	= 1575999,
 		.VCOdivider	= 2,
-		.VCOnumber	= 4,
-		.progdata	= (0 << 18) | (1 << 9) | 0x08,
+		.progdata	= (0 << 19) | (1 << 9) | 0x04,
 	},
+
+	/* band 6 */
 	{
-		.freq_low	= 1596000,
+		.freq_low	= 1576000,
 		.freq_high	= 1717999,
-		.bandselect	= 0x10,
 		.VCOdivider	= 2,
-		.VCOnumber	= 5,
-		.progdata	= (0 << 18) | (1 << 9) | 0x10,
+		.progdata	= (0 << 19) | (1 << 9) | 0x08,
 	},
+
+	/* band 7 */
 	{
 		.freq_low	= 1718000,
 		.freq_high	= 1855999,
-		.bandselect	= 0x20,
 		.VCOdivider	= 2,
-		.VCOnumber	= 6,
-		.progdata	= (0 << 18) | (1 << 9) | 0x20,
+		.progdata	= (0 << 19) | (1 << 9) | 0x10,
 	},
+
+	/* band 8 */
 	{
 		.freq_low	= 1856000,
 		.freq_high	= 2035999,
-		.bandselect	= 0x40,
 		.VCOdivider	= 2,
-		.VCOnumber	= 7,
-		.progdata	= (0 << 18) | (1 << 9) | 0x40,
+		.progdata	= (0 << 19) | (1 << 9) | 0x20,
 	},
+
+	/* band 9 */
 	{
 		.freq_low	= 2036000,
-		.freq_high	= 2149999,
-		.bandselect	= 0x80,
+		.freq_high	= 2150000,
 		.VCOdivider	= 2,
-		.VCOnumber	= 8,
-		.progdata	= (0 << 18) | (1 << 9) | 0x80,
+		.progdata	= (0 << 19) | (1 << 9) | 0x40,
 	},
 };
 
@@ -207,49 +190,44 @@
 {
 	{0x00, 0x03}, /* Reset system */
 	{0x00, 0x00}, /* Clear reset */
-	{0x01, 0x3b}, /* Apply sensible defaults, from an i2c sniffer */
-	{0x03, 0x07},
-	{0x04, 0x10},
-	{0x05, 0x04},
-	{0x06, 0x31},
-	{0x0d, 0x02},
-	{0x0e, 0x03},
-	{0x0f, 0xfe},
-	{0x10, 0x01},
-	{0x14, 0x01},
-	{0x15, 0x98},
-	{0x16, 0x00},
-	{0x17, 0x01},
-	{0x1b, 0x05},
-	{0x1c, 0x80},
-	{0x1d, 0x00},
-	{0x1e, 0x00},
-	{0x20, 0x41},
-	{0x21, 0x15},
-	{0x27, 0x14},
-	{0x28, 0x46},
-	{0x29, 0x00},
-	{0x2a, 0xb0},
-	{0x2b, 0x73},
-	{0x2c, 0x00},
+	{0x03, 0x07}, /* QPSK, DVB, Auto Acquisition (default) */
+	{0x04, 0x10}, /* MPEG */
+	{0x05, 0x04}, /* MPEG */
+	{0x06, 0x31}, /* MPEG (default) */
+	{0x0b, 0x00}, /* Freq search start point (default) */
+	{0x0c, 0x00}, /* Demodulator sample gain (default) */
+	{0x0d, 0x02}, /* Frequency search range = Fsymbol / 4 (default) */
+	{0x0e, 0x03}, /* Default non-inverted, FEC 3/4 (default) */
+	{0x0f, 0xfe}, /* FEC search mask (all supported codes) */
+	{0x10, 0x01}, /* Default search inversion, no repeat (default) */
+	{0x16, 0x00}, /* Enable reading of frequency */
+	{0x17, 0x01}, /* Enable EsNO Ready Counter */
+	{0x1c, 0x80}, /* Enable error counter */
+	{0x20, 0x00}, /* Tuner burst clock rate = 500KHz */
+	{0x21, 0x15}, /* Tuner burst mode, word length = 0x15 */
+	{0x28, 0x00}, /* Enable FILTERV with positive pol., DiSEqC 2.x off */
+	{0x29, 0x00}, /* DiSEqC LNB_DC off */
+	{0x2a, 0xb0}, /* DiSEqC Parameters (default) */
+	{0x2b, 0x73}, /* DiSEqC Tone Frequency (default) */
+	{0x2c, 0x00}, /* DiSEqC Message (0x2c - 0x31) */
 	{0x2d, 0x00},
 	{0x2e, 0x00},
 	{0x2f, 0x00},
 	{0x30, 0x00},
 	{0x31, 0x00},
-	{0x32, 0x8c},
-	{0x33, 0x00},
+	{0x32, 0x8c}, /* DiSEqC Parameters (default) */
+	{0x33, 0x00}, /* Interrupts off (0x33 - 0x34) */
 	{0x34, 0x00},
-	{0x35, 0x03},
-	{0x36, 0x02},
-	{0x37, 0x3a},
-	{0x3a, 0x00},	/* Enable AGC accumulator */
-	{0x44, 0x00},
-	{0x45, 0x00},
-	{0x46, 0x05},
-	{0x56, 0x41},
-	{0x57, 0xff},
-	{0x67, 0x83},
+	{0x35, 0x03}, /* DiSEqC Tone Amplitude (default) */
+	{0x36, 0x02}, /* DiSEqC Parameters (default) */
+	{0x37, 0x3a}, /* DiSEqC Parameters (default) */
+	{0x3a, 0x00}, /* Enable AGC accumulator (for signal strength) */
+	{0x44, 0x00}, /* Constellation (default) */
+	{0x45, 0x00}, /* Symbol count (default) */
+	{0x46, 0x0d}, /* Symbol rate estimator on (default) */
+	{0x56, 0x41}, /* Various (default) */
+	{0x57, 0xff}, /* Error Counter Window (default) */
+	{0x67, 0x83}, /* Non-DCII symbol clock */
 };
 
 static int cx24123_writereg(struct cx24123_state* state, int reg, int data)
@@ -258,6 +236,10 @@
 	struct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };
 	int err;
 
+	if (debug>1)
+		printk("cx24123: %s:  write reg 0x%02x, value 0x%02x\n",
+						__FUNCTION__,reg, data);
+
 	if ((err = i2c_transfer(state->i2c, &msg, 1)) != 1) {
 		printk("%s: writereg error(err == %i, reg == 0x%02x,"
 			 " data == 0x%02x)\n", __FUNCTION__, err, reg, data);
@@ -274,6 +256,10 @@
 	struct i2c_msg msg = { .addr = 0x08, .flags = 0, .buf = buf, .len = 2 };
 	int err;
 
+	if (debug>1)
+		printk("cx24123: %s:  writeln addr=0x08, reg 0x%02x, value 0x%02x\n",
+						__FUNCTION__,reg, data);
+
 	if ((err = i2c_transfer(state->i2c, &msg, 1)) != 1) {
 		printk("%s: writelnbreg error (err == %i, reg == 0x%02x,"
 			 " data == 0x%02x)\n", __FUNCTION__, err, reg, data);
@@ -303,6 +289,9 @@
 		return ret;
 	}
 
+	if (debug>1)
+		printk("cx24123: read reg 0x%02x, value 0x%02x\n",reg, ret);
+
 	return b1[0];
 }
 
@@ -313,17 +302,23 @@
 
 static int cx24123_set_inversion(struct cx24123_state* state, fe_spectral_inversion_t inversion)
 {
+	u8 nom_reg = cx24123_readreg(state, 0x0e);
+	u8 auto_reg = cx24123_readreg(state, 0x10);
+
 	switch (inversion) {
 	case INVERSION_OFF:
-		cx24123_writereg(state, 0x0e, cx24123_readreg(state, 0x0e) & 0x7f);
-		cx24123_writereg(state, 0x10, cx24123_readreg(state, 0x10) | 0x80);
+		dprintk("%s:  inversion off\n",__FUNCTION__);
+		cx24123_writereg(state, 0x0e, nom_reg & ~0x80);
+		cx24123_writereg(state, 0x10, auto_reg | 0x80);
 		break;
 	case INVERSION_ON:
-		cx24123_writereg(state, 0x0e, cx24123_readreg(state, 0x0e) | 0x80);
-		cx24123_writereg(state, 0x10, cx24123_readreg(state, 0x10) | 0x80);
+		dprintk("%s:  inversion on\n",__FUNCTION__);
+		cx24123_writereg(state, 0x0e, nom_reg | 0x80);
+		cx24123_writereg(state, 0x10, auto_reg | 0x80);
 		break;
 	case INVERSION_AUTO:
-		cx24123_writereg(state, 0x10, cx24123_readreg(state, 0x10) & 0x7f);
+		dprintk("%s:  inversion auto\n",__FUNCTION__);
+		cx24123_writereg(state, 0x10, auto_reg & ~0x80);
 		break;
 	default:
 		return -EINVAL;
@@ -338,92 +333,191 @@
 
 	val = cx24123_readreg(state, 0x1b) >> 7;
 
-	if (val == 0)
+	if (val == 0) {
+		dprintk("%s:  read inversion off\n",__FUNCTION__);
 		*inversion = INVERSION_OFF;
-	else
+	} else {
+		dprintk("%s:  read inversion on\n",__FUNCTION__);
 		*inversion = INVERSION_ON;
+	}
 
 	return 0;
 }
 
 static int cx24123_set_fec(struct cx24123_state* state, fe_code_rate_t fec)
 {
+	u8 nom_reg = cx24123_readreg(state, 0x0e) & ~0x07;
+
 	if ( (fec < FEC_NONE) || (fec > FEC_AUTO) )
 		fec = FEC_AUTO;
 
-	/* Hardware has 5/11 and 3/5 but are never unused */
 	switch (fec) {
-	case FEC_NONE:
-		return cx24123_writereg(state, 0x0f, 0x01);
 	case FEC_1_2:
-		return cx24123_writereg(state, 0x0f, 0x02);
+		dprintk("%s:  set FEC to 1/2\n",__FUNCTION__);
+		cx24123_writereg(state, 0x0e, nom_reg | 0x01);
+		cx24123_writereg(state, 0x0f, 0x02);
+		break;
 	case FEC_2_3:
-		return cx24123_writereg(state, 0x0f, 0x04);
+		dprintk("%s:  set FEC to 2/3\n",__FUNCTION__);
+		cx24123_writereg(state, 0x0e, nom_reg | 0x02);
+		cx24123_writereg(state, 0x0f, 0x04);
+		break;
 	case FEC_3_4:
-		return cx24123_writereg(state, 0x0f, 0x08);
+		dprintk("%s:  set FEC to 3/4\n",__FUNCTION__);
+		cx24123_writereg(state, 0x0e, nom_reg | 0x03);
+		cx24123_writereg(state, 0x0f, 0x08);
+		break;
+	case FEC_4_5:
+		dprintk("%s:  set FEC to 4/5\n",__FUNCTION__);
+		cx24123_writereg(state, 0x0e, nom_reg | 0x04);
+		cx24123_writereg(state, 0x0f, 0x10);
+		break;
 	case FEC_5_6:
-		return cx24123_writereg(state, 0x0f, 0x20);
+		dprintk("%s:  set FEC to 5/6\n",__FUNCTION__);
+		cx24123_writereg(state, 0x0e, nom_reg | 0x05);
+		cx24123_writereg(state, 0x0f, 0x20);
+		break;
+	case FEC_6_7:
+		dprintk("%s:  set FEC to 6/7\n",__FUNCTION__);
+		cx24123_writereg(state, 0x0e, nom_reg | 0x06);
+		cx24123_writereg(state, 0x0f, 0x40);
+		break;
 	case FEC_7_8:
-		return cx24123_writereg(state, 0x0f, 0x80);
+		dprintk("%s:  set FEC to 7/8\n",__FUNCTION__);
+		cx24123_writereg(state, 0x0e, nom_reg | 0x07);
+		cx24123_writereg(state, 0x0f, 0x80);
+		break;
 	case FEC_AUTO:
-		return cx24123_writereg(state, 0x0f, 0xae);
+		dprintk("%s:  set FEC to auto\n",__FUNCTION__);
+		cx24123_writereg(state, 0x0f, 0xfe);
+		break;
 	default:
 		return -EOPNOTSUPP;
 	}
+
+	return 0;
 }
 
 static int cx24123_get_fec(struct cx24123_state* state, fe_code_rate_t *fec)
 {
 	int ret;
-	u8 val;
 
 	ret = cx24123_readreg (state, 0x1b);
 	if (ret < 0)
 		return ret;
-	val = ret & 0x07;
-	switch (val) {
+	ret = ret & 0x07;
+
+	switch (ret) {
 	case 1:
 		*fec = FEC_1_2;
 		break;
-	case 3:
+	case 2:
 		*fec = FEC_2_3;
 		break;
-	case 4:
+	case 3:
 		*fec = FEC_3_4;
 		break;
-	case 5:
+	case 4:
 		*fec = FEC_4_5;
 		break;
-	case 6:
+	case 5:
 		*fec = FEC_5_6;
 		break;
+	case 6:
+		*fec = FEC_6_7;
+		break;
 	case 7:
 		*fec = FEC_7_8;
 		break;
-	case 2:	/* *fec = FEC_3_5; break; */
-	case 0:	/* *fec = FEC_5_11; break; */
-		*fec = FEC_AUTO;
-		break;
 	default:
-		*fec = FEC_NONE; // can't happen
+		/* this can happen when there's no lock */
+		*fec = FEC_NONE;
 	}
 
 	return 0;
 }
 
-/* fixme: Symbol rates < 3MSps may not work because of precision loss */
+/* Approximation of closest integer of log2(a/b). It actually gives the
+   lowest integer i such that 2^i >= round(a/b) */
+static u32 cx24123_int_log2(u32 a, u32 b)
+{
+	u32 exp, nearest = 0;
+	u32 div = a / b;
+	if(a % b >= b / 2) ++div;
+	if(div < (1 << 31))
+	{
+		for(exp = 1; div > exp; nearest++)
+			exp += exp;
+	}
+	return nearest;
+}
+
 static int cx24123_set_symbolrate(struct cx24123_state* state, u32 srate)
 {
-	u32 val;
+	u32 tmp, sample_rate, ratio, sample_gain;
+	u8 pll_mult;
+
+	/*  check if symbol rate is within limits */
+	if ((srate > state->ops.info.symbol_rate_max) ||
+	    (srate < state->ops.info.symbol_rate_min))
+		return -EOPNOTSUPP;;
+
+	/* choose the sampling rate high enough for the required operation,
+	   while optimizing the power consumed by the demodulator */
+	if (srate < (XTAL*2)/2)
+		pll_mult = 2;
+	else if (srate < (XTAL*3)/2)
+		pll_mult = 3;
+	else if (srate < (XTAL*4)/2)
+		pll_mult = 4;
+	else if (srate < (XTAL*5)/2)
+		pll_mult = 5;
+	else if (srate < (XTAL*6)/2)
+		pll_mult = 6;
+	else if (srate < (XTAL*7)/2)
+		pll_mult = 7;
+	else if (srate < (XTAL*8)/2)
+		pll_mult = 8;
+	else
+		pll_mult = 9;
+
+
+	sample_rate = pll_mult * XTAL;
+
+	/*
+	    SYSSymbolRate[21:0] = (srate << 23) / sample_rate
+
+	    We have to use 32 bit unsigned arithmetic without precision loss.
+	    The maximum srate is 45000000 or 0x02AEA540. This number has
+	    only 6 clear bits on top, hence we can shift it left only 6 bits
+	    at a time. Borrowed from cx24110.c
+	*/
+
+	tmp = srate << 6;
+	ratio = tmp / sample_rate;
+
+	tmp = (tmp % sample_rate) << 6;
+	ratio = (ratio << 6) + (tmp / sample_rate);
+
+	tmp = (tmp % sample_rate) << 6;
+	ratio = (ratio << 6) + (tmp / sample_rate);
+
+	tmp = (tmp % sample_rate) << 5;
+	ratio = (ratio << 5) + (tmp / sample_rate);
+
 
-	val = (srate / 1185) * 100;
+	cx24123_writereg(state, 0x01, pll_mult * 6);
 
-	/* Compensate for scaling up, by removing 17 symbols per 1Msps */
-	val = val - (17 * (srate / 1000000));
+	cx24123_writereg(state, 0x08, (ratio >> 16) & 0x3f );
+	cx24123_writereg(state, 0x09, (ratio >>  8) & 0xff );
+	cx24123_writereg(state, 0x0a, (ratio      ) & 0xff );
 
-	cx24123_writereg(state, 0x08, (val >> 16) & 0xff );
-	cx24123_writereg(state, 0x09, (val >>  8) & 0xff );
-	cx24123_writereg(state, 0x0a, (val      ) & 0xff );
+	/* also set the demodulator sample gain */
+	sample_gain = cx24123_int_log2(sample_rate, srate);
+	tmp = cx24123_readreg(state, 0x0c) & ~0xe0;
+	cx24123_writereg(state, 0x0c, tmp | sample_gain << 5);
+
+	dprintk("%s: srate=%d, ratio=0x%08x, sample_rate=%i sample_gain=%d\n", __FUNCTION__, srate, ratio, sample_rate, sample_gain);
 
 	return 0;
 }
@@ -437,6 +531,9 @@
 	struct cx24123_state *state = fe->demodulator_priv;
 	u32 ndiv = 0, adiv = 0, vco_div = 0;
 	int i = 0;
+	int pump = 2;
+	int band = 0;
+	int num_bands = sizeof(cx24123_bandselect_vals) / sizeof(cx24123_bandselect_vals[0]);
 
 	/* Defaults for low freq, low rate */
 	state->VCAarg = cx24123_AGC_vals[0].VCAprogdata;
@@ -444,38 +541,49 @@
 	state->bandselectarg = cx24123_bandselect_vals[0].progdata;
 	vco_div = cx24123_bandselect_vals[0].VCOdivider;
 
-	/* For the given symbolerate, determine the VCA and VGA programming bits */
+	/* For the given symbol rate, determine the VCA, VGA and FILTUNE programming bits */
 	for (i = 0; i < sizeof(cx24123_AGC_vals) / sizeof(cx24123_AGC_vals[0]); i++)
 	{
 		if ((cx24123_AGC_vals[i].symbolrate_low <= p->u.qpsk.symbol_rate) &&
-				(cx24123_AGC_vals[i].symbolrate_high >= p->u.qpsk.symbol_rate) ) {
+		    (cx24123_AGC_vals[i].symbolrate_high >= p->u.qpsk.symbol_rate) ) {
 			state->VCAarg = cx24123_AGC_vals[i].VCAprogdata;
 			state->VGAarg = cx24123_AGC_vals[i].VGAprogdata;
+			state->FILTune = cx24123_AGC_vals[i].FILTune;
 		}
 	}
 
-	/* For the given frequency, determine the bandselect programming bits */
-	for (i = 0; i < sizeof(cx24123_bandselect_vals) / sizeof(cx24123_bandselect_vals[0]); i++)
+	/* determine the band to use */
+	if(force_band < 1 || force_band > num_bands)
 	{
-		if ((cx24123_bandselect_vals[i].freq_low <= p->frequency) &&
-				(cx24123_bandselect_vals[i].freq_high >= p->frequency) ) {
-			state->bandselectarg = cx24123_bandselect_vals[i].progdata;
-			vco_div = cx24123_bandselect_vals[i].VCOdivider;
+		for (i = 0; i < num_bands; i++)
+		{
+			if ((cx24123_bandselect_vals[i].freq_low <= p->frequency) &&
+			    (cx24123_bandselect_vals[i].freq_high >= p->frequency) )
+				band = i;
 		}
 	}
+	else
+		band = force_band - 1;
+
+	state->bandselectarg = cx24123_bandselect_vals[band].progdata;
+	vco_div = cx24123_bandselect_vals[band].VCOdivider;
+
+	/* determine the charge pump current */
+	if ( p->frequency < (cx24123_bandselect_vals[band].freq_low + cx24123_bandselect_vals[band].freq_high)/2 )
+		pump = 0x01;
+	else
+		pump = 0x02;
 
 	/* Determine the N/A dividers for the requested lband freq (in kHz). */
-	/* Note: 10111 (kHz) is the Crystal Freq and divider of 10. */
-	ndiv = ( ((p->frequency * vco_div) / (10111 / 10) / 2) / 32) & 0x1ff;
-	adiv = ( ((p->frequency * vco_div) / (10111 / 10) / 2) % 32) & 0x1f;
+	/* Note: the reference divider R=10, frequency is in KHz, XTAL is in Hz */
+	ndiv = ( ((p->frequency * vco_div * 10) / (2 * XTAL / 1000)) / 32) & 0x1ff;
+	adiv = ( ((p->frequency * vco_div * 10) / (2 * XTAL / 1000)) % 32) & 0x1f;
 
 	if (adiv == 0)
-		adiv++;
+		ndiv++;
 
-	/* determine the correct pll frequency values. */
-	/* Command 11, refdiv 11, cpump polarity 1, cpump current 3mA 10. */
-	state->pllarg = (3 << 19) | (3 << 17) | (1 << 16) | (2 << 14);
-	state->pllarg |= (ndiv << 5) | adiv;
+	/* control bits 11, refdiv 11, charge pump polarity 1, charge pump current, ndiv, adiv */
+	state->pllarg = (3 << 19) | (3 << 17) | (1 << 16) | (pump << 14) | (ndiv << 5) | adiv;
 
 	return 0;
 }
@@ -489,6 +597,8 @@
 	struct cx24123_state *state = fe->demodulator_priv;
 	unsigned long timeout;
 
+	dprintk("%s:  pll writereg called, data=0x%08x\n",__FUNCTION__,data);
+
 	/* align the 21 bytes into to bit23 boundary */
 	data = data << 3;
 
@@ -538,6 +648,9 @@
 static int cx24123_pll_tune(struct dvb_frontend* fe, struct dvb_frontend_parameters *p)
 {
 	struct cx24123_state *state = fe->demodulator_priv;
+	u8 val;
+
+	dprintk("frequency=%i\n", p->frequency);
 
 	if (cx24123_pll_calculate(fe, p) != 0) {
 		printk("%s: cx24123_pll_calcutate failed\n",__FUNCTION__);
@@ -552,6 +665,14 @@
 	cx24123_pll_writereg(fe, p, state->bandselectarg);
 	cx24123_pll_writereg(fe, p, state->pllarg);
 
+	/* set the FILTUNE voltage */
+	val = cx24123_readreg(state, 0x28) & ~0x3;
+	cx24123_writereg(state, 0x27, state->FILTune >> 2);
+	cx24123_writereg(state, 0x28, val | (state->FILTune & 0x3));
+
+	dprintk("%s:  pll tune VCA=%d, band=%d, pll=%d\n",__FUNCTION__,state->VCAarg,
+			state->bandselectarg,state->pllarg);
+
 	return 0;
 }
 
@@ -560,6 +681,8 @@
 	struct cx24123_state *state = fe->demodulator_priv;
 	int i;
 
+	dprintk("%s:  init frontend\n",__FUNCTION__);
+
 	/* Configure the demod to a good set of defaults */
 	for (i = 0; i < sizeof(cx24123_regdata) / sizeof(cx24123_regdata[0]); i++)
 		cx24123_writereg(state, cx24123_regdata[i].reg, cx24123_regdata[i].data);
@@ -587,10 +710,13 @@
 
 		switch (voltage) {
 		case SEC_VOLTAGE_13:
+			dprintk("%s:  isl6421 voltage = 13V\n",__FUNCTION__);
 			return cx24123_writelnbreg(state, 0x0, val & 0x32); /* V 13v */
 		case SEC_VOLTAGE_18:
+			dprintk("%s:  isl6421 voltage = 18V\n",__FUNCTION__);
 			return cx24123_writelnbreg(state, 0x0, val | 0x04); /* H 18v */
 		case SEC_VOLTAGE_OFF:
+			dprintk("%s:  isl5421 voltage off\n",__FUNCTION__);
 			return cx24123_writelnbreg(state, 0x0, val & 0x30);
 		default:
 			return -EINVAL;
@@ -624,13 +750,93 @@
 	return 0;
 }
 
-static int cx24123_send_diseqc_msg(struct dvb_frontend* fe,
-				   struct dvb_diseqc_master_cmd *cmd)
+/* wait for diseqc queue to become ready (or timeout) */
+static void cx24123_wait_for_diseqc(struct cx24123_state *state)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(200);
+	while (!(cx24123_readreg(state, 0x29) & 0x40)) {
+		if(time_after(jiffies, timeout)) {
+			printk("%s: diseqc queue not ready, command may be lost.\n", __FUNCTION__);
+			break;
+		}
+		msleep(10);
+	}
+}
+
+static int cx24123_send_diseqc_msg(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)
+{
+	struct cx24123_state *state = fe->demodulator_priv;
+	int i, val;
+
+	dprintk("%s:\n",__FUNCTION__);
+
+	/* check if continuous tone has been stopped */
+	if (state->config->use_isl6421)
+		val = cx24123_readlnbreg(state, 0x00) & 0x10;
+	else
+		val = cx24123_readreg(state, 0x29) & 0x10;
+
+
+	if (val) {
+		printk("%s: ERROR: attempt to send diseqc command before tone is off\n", __FUNCTION__);
+		return -ENOTSUPP;
+	}
+
+	/* wait for diseqc queue ready */
+	cx24123_wait_for_diseqc(state);
+
+	/* select tone mode */
+	cx24123_writereg(state, 0x2a, cx24123_readreg(state, 0x2a) & 0xf8);
+
+	for (i = 0; i < cmd->msg_len; i++)
+		cx24123_writereg(state, 0x2C + i, cmd->msg[i]);
+
+	val = cx24123_readreg(state, 0x29);
+	cx24123_writereg(state, 0x29, ((val & 0x90) | 0x40) | ((cmd->msg_len-3) & 3));
+
+	/* wait for diseqc message to finish sending */
+	cx24123_wait_for_diseqc(state);
+
+	return 0;
+}
+
+static int cx24123_diseqc_send_burst(struct dvb_frontend* fe, fe_sec_mini_cmd_t burst)
 {
-	/* fixme: Implement diseqc */
-	printk("%s: No support yet\n",__FUNCTION__);
+	struct cx24123_state *state = fe->demodulator_priv;
+	int val;
+
+	dprintk("%s:\n", __FUNCTION__);
+
+	/* check if continuous tone has been stoped */
+	if (state->config->use_isl6421)
+		val = cx24123_readlnbreg(state, 0x00) & 0x10;
+	else
+		val = cx24123_readreg(state, 0x29) & 0x10;
+
+
+	if (val) {
+		printk("%s: ERROR: attempt to send diseqc command before tone is off\n", __FUNCTION__);
+		return -ENOTSUPP;
+	}
+
+	cx24123_wait_for_diseqc(state);
 
-	return -ENOTSUPP;
+	/* select tone mode */
+	val = cx24123_readreg(state, 0x2a) & 0xf8;
+	cx24123_writereg(state, 0x2a, val | 0x04);
+
+	val = cx24123_readreg(state, 0x29);
+
+	if (burst == SEC_MINI_A)
+		cx24123_writereg(state, 0x29, ((val & 0x90) | 0x40 | 0x00));
+	else if (burst == SEC_MINI_B)
+		cx24123_writereg(state, 0x29, ((val & 0x90) | 0x40 | 0x08));
+	else
+		return -EINVAL;
+
+	cx24123_wait_for_diseqc(state);
+
+	return 0;
 }
 
 static int cx24123_read_status(struct dvb_frontend* fe, fe_status_t* status)
@@ -642,13 +848,15 @@
 
 	*status = 0;
 	if (lock & 0x01)
-		*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;
+		*status |= FE_HAS_SIGNAL;
+	if (sync & 0x02)
+		*status |= FE_HAS_CARRIER;
 	if (sync & 0x04)
 		*status |= FE_HAS_VITERBI;
 	if (sync & 0x08)
-		*status |= FE_HAS_CARRIER;
+		*status |= FE_HAS_SYNC;
 	if (sync & 0x80)
-		*status |= FE_HAS_SYNC | FE_HAS_LOCK;
+		*status |= FE_HAS_LOCK;
 
 	return 0;
 }
@@ -681,6 +889,8 @@
 	else
 		state->snr = 0;
 
+	dprintk("%s:  BER = %d, S/N index = %d\n",__FUNCTION__,state->lastber, state->snr);
+
 	*ber = state->lastber;
 
 	return 0;
@@ -691,6 +901,8 @@
 	struct cx24123_state *state = fe->demodulator_priv;
 	*signal_strength = cx24123_readreg(state, 0x3b) << 8; /* larger = better */
 
+	dprintk("%s:  Signal strength = %d\n",__FUNCTION__,*signal_strength);
+
 	return 0;
 }
 
@@ -699,6 +911,8 @@
 	struct cx24123_state *state = fe->demodulator_priv;
 	*snr = state->snr;
 
+	dprintk("%s:  read S/N index = %d\n",__FUNCTION__,*snr);
+
 	return 0;
 }
 
@@ -707,6 +921,8 @@
 	struct cx24123_state *state = fe->demodulator_priv;
 	*ucblocks = state->lastber;
 
+	dprintk("%s:  ucblocks (ber) = %d\n",__FUNCTION__,*ucblocks);
+
 	return 0;
 }
 
@@ -714,6 +930,8 @@
 {
 	struct cx24123_state *state = fe->demodulator_priv;
 
+	dprintk("%s:  set_frontend\n",__FUNCTION__);
+
 	if (state->config->set_ts_params)
 		state->config->set_ts_params(fe, 0);
 
@@ -737,6 +955,8 @@
 {
 	struct cx24123_state *state = fe->demodulator_priv;
 
+	dprintk("%s:  get_frontend\n",__FUNCTION__);
+
 	if (cx24123_get_inversion(state, &p->inversion) != 0) {
 		printk("%s: Failed to get inversion status\n",__FUNCTION__);
 		return -EREMOTEIO;
@@ -763,8 +983,10 @@
 
 		switch (tone) {
 		case SEC_TONE_ON:
+			dprintk("%s:  isl6421 sec tone on\n",__FUNCTION__);
 			return cx24123_writelnbreg(state, 0x0, val | 0x10);
 		case SEC_TONE_OFF:
+			dprintk("%s:  isl6421 sec tone off\n",__FUNCTION__);
 			return cx24123_writelnbreg(state, 0x0, val & 0x2f);
 		default:
 			printk("%s: CASE reached default with tone=%d\n", __FUNCTION__, tone);
@@ -855,12 +1077,13 @@
 		.frequency_min = 950000,
 		.frequency_max = 2150000,
 		.frequency_stepsize = 1011, /* kHz for QPSK frontends */
-		.frequency_tolerance = 29500,
+		.frequency_tolerance = 5000,
 		.symbol_rate_min = 1000000,
 		.symbol_rate_max = 45000000,
 		.caps = FE_CAN_INVERSION_AUTO |
 			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
-			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
+			FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
 			FE_CAN_QPSK | FE_CAN_RECOVER
 	},
 
@@ -875,12 +1098,16 @@
 	.read_snr = cx24123_read_snr,
 	.read_ucblocks = cx24123_read_ucblocks,
 	.diseqc_send_master_cmd = cx24123_send_diseqc_msg,
+	.diseqc_send_burst = cx24123_diseqc_send_burst,
 	.set_tone = cx24123_set_tone,
 	.set_voltage = cx24123_set_voltage,
 };
 
 module_param(debug, int, 0644);
-MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+MODULE_PARM_DESC(debug, "Activates frontend debugging (default:0)");
+
+module_param(force_band, int, 0644);
+MODULE_PARM_DESC(force_band, "Force a specific band select (1-9, default:off).");
 
 MODULE_DESCRIPTION("DVB Frontend module for Conexant cx24123/cx24109 hardware");
 MODULE_AUTHOR("Steven Toth");
